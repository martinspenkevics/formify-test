const Tn =
  '/*! tailwindcss v4.1.3 | MIT License | https://tailwindcss.com */@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-space-y-reverse:0;--tw-border-style:solid;--tw-font-weight:initial;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--color-red-600:oklch(57.7% .245 27.325);--color-amber-600:oklch(66.6% .179 58.318);--color-green-600:oklch(62.7% .194 149.214);--color-blue-500:oklch(62.3% .214 259.815);--color-blue-600:oklch(54.6% .245 262.881);--color-indigo-600:oklch(51.1% .262 276.966);--color-gray-50:oklch(98.5% .002 247.839);--color-gray-100:oklch(96.7% .003 264.542);--color-gray-500:oklch(55.1% .027 264.364);--color-gray-600:oklch(44.6% .03 256.802);--color-gray-700:oklch(37.3% .034 259.733);--color-white:#fff;--spacing:.25rem;--text-sm:.875rem;--text-sm--line-height:calc(1.25/.875);--text-lg:1.125rem;--text-lg--line-height:calc(1.75/1.125);--text-xl:1.25rem;--text-xl--line-height:calc(1.75/1.25);--text-2xl:1.5rem;--text-2xl--line-height:calc(2/1.5);--font-weight-medium:500;--font-weight-semibold:600;--font-weight-bold:700;--radius-lg:.5rem;--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono)}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::placeholder{opacity:1}@supports (not ((-webkit-appearance:-apple-pay-button))) or (contain-intrinsic-size:1px){::placeholder{color:currentColor}@supports (color:color-mix(in lab,red,red)){::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){-webkit-appearance:button;-moz-appearance:button;appearance:button}::file-selector-button{-webkit-appearance:button;-moz-appearance:button;appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}}@layer components;@layer utilities{.mt-10{margin-top:calc(var(--spacing)*10)}.mb-2{margin-bottom:calc(var(--spacing)*2)}.ml-2{margin-left:calc(var(--spacing)*2)}.ml-4{margin-left:calc(var(--spacing)*4)}.flex{display:flex}.w-full{width:100%}.flex-1{flex:1}.list-inside{list-style-position:inside}.list-disc{list-style-type:disc}.items-center{align-items:center}.justify-between{justify-content:space-between}.gap-2{gap:calc(var(--spacing)*2)}.gap-4{gap:calc(var(--spacing)*4)}:where(.space-y-1>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(calc(var(--spacing)*1)*var(--tw-space-y-reverse));margin-block-end:calc(calc(var(--spacing)*1)*calc(1 - var(--tw-space-y-reverse)))}:where(.space-y-2>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(calc(var(--spacing)*2)*var(--tw-space-y-reverse));margin-block-end:calc(calc(var(--spacing)*2)*calc(1 - var(--tw-space-y-reverse)))}:where(.space-y-4>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(calc(var(--spacing)*4)*var(--tw-space-y-reverse));margin-block-end:calc(calc(var(--spacing)*4)*calc(1 - var(--tw-space-y-reverse)))}:where(.space-y-6>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(calc(var(--spacing)*6)*var(--tw-space-y-reverse));margin-block-end:calc(calc(var(--spacing)*6)*calc(1 - var(--tw-space-y-reverse)))}.rounded{border-radius:.25rem}.rounded-lg{border-radius:var(--radius-lg)}.border{border-style:var(--tw-border-style);border-width:1px}.bg-amber-600{background-color:var(--color-amber-600)}.bg-blue-500{background-color:var(--color-blue-500)}.bg-blue-600{background-color:var(--color-blue-600)}.bg-gray-50{background-color:var(--color-gray-50)}.bg-gray-100{background-color:var(--color-gray-100)}.bg-gray-600{background-color:var(--color-gray-600)}.bg-green-600{background-color:var(--color-green-600)}.bg-indigo-600{background-color:var(--color-indigo-600)}.p-1{padding:calc(var(--spacing)*1)}.p-2{padding:calc(var(--spacing)*2)}.p-4{padding:calc(var(--spacing)*4)}.px-4{padding-inline:calc(var(--spacing)*4)}.py-2{padding-block:calc(var(--spacing)*2)}.text-2xl{font-size:var(--text-2xl);line-height:var(--tw-leading,var(--text-2xl--line-height))}.text-lg{font-size:var(--text-lg);line-height:var(--tw-leading,var(--text-lg--line-height))}.text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.text-xl{font-size:var(--text-xl);line-height:var(--tw-leading,var(--text-xl--line-height))}.font-bold{--tw-font-weight:var(--font-weight-bold);font-weight:var(--font-weight-bold)}.font-medium{--tw-font-weight:var(--font-weight-medium);font-weight:var(--font-weight-medium)}.font-semibold{--tw-font-weight:var(--font-weight-semibold);font-weight:var(--font-weight-semibold)}.text-blue-600{color:var(--color-blue-600)}.text-gray-500{color:var(--color-gray-500)}.text-gray-700{color:var(--color-gray-700)}.text-red-600{color:var(--color-red-600)}.text-white{color:var(--color-white)}.italic{font-style:italic}.shadow{--tw-shadow:0 1px 3px 0 var(--tw-shadow-color,#0000001a),0 1px 2px -1px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}}@property --tw-space-y-reverse{syntax:"*";inherits:false;initial-value:0}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-font-weight{syntax:"*";inherits:false}@property --tw-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-shadow-color{syntax:"*";inherits:false}@property --tw-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-inset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-shadow-color{syntax:"*";inherits:false}@property --tw-inset-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-ring-color{syntax:"*";inherits:false}@property --tw-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-ring-color{syntax:"*";inherits:false}@property --tw-inset-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-ring-inset{syntax:"*";inherits:false}@property --tw-ring-offset-width{syntax:"<length>";inherits:false;initial-value:0}@property --tw-ring-offset-color{syntax:"*";inherits:false;initial-value:#fff}@property --tw-ring-offset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}';
/**
 * @vue/shared v3.5.13
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function Ze(e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const o of e.split(",")) t[o] = 1;
  return (o) => o in t;
}
const J = process.env.NODE_ENV !== "production" ? Object.freeze({}) : {},
  Ct = process.env.NODE_ENV !== "production" ? Object.freeze([]) : [],
  ie = () => {},
  ir = () => !1,
  oo = (e) =>
    e.charCodeAt(0) === 111 &&
    e.charCodeAt(1) === 110 && // uppercase letter
    (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97),
  Oo = (e) => e.startsWith("onUpdate:"),
  ee = Object.assign,
  $n = (e, t) => {
    const o = e.indexOf(t);
    o > -1 && e.splice(o, 1);
  },
  rr = Object.prototype.hasOwnProperty,
  W = (e, t) => rr.call(e, t),
  $ = Array.isArray,
  _t = (e) => no(e) === "[object Map]",
  Uo = (e) => no(e) === "[object Set]",
  ss = (e) => no(e) === "[object Date]",
  I = (e) => typeof e == "function",
  q = (e) => typeof e == "string",
  He = (e) => typeof e == "symbol",
  G = (e) => e !== null && typeof e == "object",
  An = (e) => (G(e) || I(e)) && I(e.then) && I(e.catch),
  zs = Object.prototype.toString,
  no = (e) => zs.call(e),
  Pn = (e) => no(e).slice(8, -1),
  Lo = (e) => no(e) === "[object Object]",
  kn = (e) => q(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e,
  Wt = /* @__PURE__ */ Ze(
    // the leading comma is intentional so empty string "" is also included
    ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
  ),
  lr = /* @__PURE__ */ Ze(
    "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
  ),
  Ho = (e) => {
    const t = /* @__PURE__ */ Object.create(null);
    return (o) => t[o] || (t[o] = e(o));
  },
  cr = /-(\w)/g,
  be = Ho((e) => e.replace(cr, (t, o) => (o ? o.toUpperCase() : ""))),
  ar = /\B([A-Z])/g,
  we = Ho((e) => e.replace(ar, "-$1").toLowerCase()),
  Bo = Ho((e) => e.charAt(0).toUpperCase() + e.slice(1)),
  gt = Ho((e) => (e ? `on${Bo(e)}` : "")),
  ft = (e, t) => !Object.is(e, t),
  Dt = (e, ...t) => {
    for (let o = 0; o < e.length; o++) e[o](...t);
  },
  xo = (e, t, o, n = !1) => {
    Object.defineProperty(e, t, {
      configurable: !0,
      enumerable: !1,
      writable: n,
      value: o,
    });
  },
  Vo = (e) => {
    const t = parseFloat(e);
    return isNaN(t) ? e : t;
  },
  is = (e) => {
    const t = q(e) ? Number(e) : NaN;
    return isNaN(t) ? e : t;
  };
let rs;
const so = () =>
  rs ||
  (rs =
    typeof globalThis < "u"
      ? globalThis
      : typeof self < "u"
      ? self
      : typeof window < "u"
      ? window
      : typeof global < "u"
      ? global
      : {});
function Rn(e) {
  if ($(e)) {
    const t = {};
    for (let o = 0; o < e.length; o++) {
      const n = e[o],
        s = q(n) ? pr(n) : Rn(n);
      if (s) for (const i in s) t[i] = s[i];
    }
    return t;
  } else if (q(e) || G(e)) return e;
}
const ur = /;(?![^(]*\))/g,
  fr = /:([^]+)/,
  dr = /\/\*[^]*?\*\//g;
function pr(e) {
  const t = {};
  return (
    e
      .replace(dr, "")
      .split(ur)
      .forEach((o) => {
        if (o) {
          const n = o.split(fr);
          n.length > 1 && (t[n[0].trim()] = n[1].trim());
        }
      }),
    t
  );
}
function Mn(e) {
  let t = "";
  if (q(e)) t = e;
  else if ($(e))
    for (let o = 0; o < e.length; o++) {
      const n = Mn(e[o]);
      n && (t += n + " ");
    }
  else if (G(e)) for (const o in e) e[o] && (t += o + " ");
  return t.trim();
}
const hr =
    "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot",
  gr =
    "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view",
  mr =
    "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics",
  _r = /* @__PURE__ */ Ze(hr),
  vr = /* @__PURE__ */ Ze(gr),
  br = /* @__PURE__ */ Ze(mr),
  yr =
    "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
  Er = /* @__PURE__ */ Ze(yr);
function Js(e) {
  return !!e || e === "";
}
function Nr(e, t) {
  if (e.length !== t.length) return !1;
  let o = !0;
  for (let n = 0; o && n < e.length; n++) o = At(e[n], t[n]);
  return o;
}
function At(e, t) {
  if (e === t) return !0;
  let o = ss(e),
    n = ss(t);
  if (o || n) return o && n ? e.getTime() === t.getTime() : !1;
  if (((o = He(e)), (n = He(t)), o || n)) return e === t;
  if (((o = $(e)), (n = $(t)), o || n)) return o && n ? Nr(e, t) : !1;
  if (((o = G(e)), (n = G(t)), o || n)) {
    if (!o || !n) return !1;
    const s = Object.keys(e).length,
      i = Object.keys(t).length;
    if (s !== i) return !1;
    for (const r in e) {
      const l = e.hasOwnProperty(r),
        a = t.hasOwnProperty(r);
      if ((l && !a) || (!l && a) || !At(e[r], t[r])) return !1;
    }
  }
  return String(e) === String(t);
}
function wr(e, t) {
  return e.findIndex((o) => At(o, t));
}
const Gs = (e) => !!(e && e.__v_isRef === !0),
  F = (e) =>
    q(e)
      ? e
      : e == null
      ? ""
      : $(e) || (G(e) && (e.toString === zs || !I(e.toString)))
      ? Gs(e)
        ? F(e.value)
        : JSON.stringify(e, Ys, 2)
      : String(e),
  Ys = (e, t) =>
    Gs(t)
      ? Ys(e, t.value)
      : _t(t)
      ? {
          [`Map(${t.size})`]: [...t.entries()].reduce(
            (o, [n, s], i) => ((o[nn(n, i) + " =>"] = s), o),
            {}
          ),
        }
      : Uo(t)
      ? {
          [`Set(${t.size})`]: [...t.values()].map((o) => nn(o)),
        }
      : He(t)
      ? nn(t)
      : G(t) && !$(t) && !Lo(t)
      ? String(t)
      : t,
  nn = (e, t = "") => {
    var o;
    return (
      // Symbol.description in es2019+ so we need to cast here to pass
      // the lib: es2016 check
      He(e) ? `Symbol(${(o = e.description) != null ? o : t})` : e
    );
  };
/**
 * @vue/reactivity v3.5.13
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
function Be(e, ...t) {
  console.warn(`[Vue warn] ${e}`, ...t);
}
let Ne;
class Or {
  constructor(t = !1) {
    (this.detached = t),
      (this._active = !0),
      (this.effects = []),
      (this.cleanups = []),
      (this._isPaused = !1),
      (this.parent = Ne),
      !t && Ne && (this.index = (Ne.scopes || (Ne.scopes = [])).push(this) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let t, o;
      if (this.scopes)
        for (t = 0, o = this.scopes.length; t < o; t++) this.scopes[t].pause();
      for (t = 0, o = this.effects.length; t < o; t++) this.effects[t].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let t, o;
      if (this.scopes)
        for (t = 0, o = this.scopes.length; t < o; t++) this.scopes[t].resume();
      for (t = 0, o = this.effects.length; t < o; t++) this.effects[t].resume();
    }
  }
  run(t) {
    if (this._active) {
      const o = Ne;
      try {
        return (Ne = this), t();
      } finally {
        Ne = o;
      }
    } else
      process.env.NODE_ENV !== "production" &&
        Be("cannot run an inactive effect scope.");
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    Ne = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    Ne = this.parent;
  }
  stop(t) {
    if (this._active) {
      this._active = !1;
      let o, n;
      for (o = 0, n = this.effects.length; o < n; o++) this.effects[o].stop();
      for (this.effects.length = 0, o = 0, n = this.cleanups.length; o < n; o++)
        this.cleanups[o]();
      if (((this.cleanups.length = 0), this.scopes)) {
        for (o = 0, n = this.scopes.length; o < n; o++) this.scopes[o].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !t) {
        const s = this.parent.scopes.pop();
        s &&
          s !== this &&
          ((this.parent.scopes[this.index] = s), (s.index = this.index));
      }
      this.parent = void 0;
    }
  }
}
function xr() {
  return Ne;
}
let z;
const sn = /* @__PURE__ */ new WeakSet();
class Qs {
  constructor(t) {
    (this.fn = t),
      (this.deps = void 0),
      (this.depsTail = void 0),
      (this.flags = 5),
      (this.next = void 0),
      (this.cleanup = void 0),
      (this.scheduler = void 0),
      Ne && Ne.active && Ne.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 &&
      ((this.flags &= -65), sn.has(this) && (sn.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    (this.flags & 2 && !(this.flags & 32)) || this.flags & 8 || Zs(this);
  }
  run() {
    if (!(this.flags & 1)) return this.fn();
    (this.flags |= 2), ls(this), qs(this);
    const t = z,
      o = $e;
    (z = this), ($e = !0);
    try {
      return this.fn();
    } finally {
      process.env.NODE_ENV !== "production" &&
        z !== this &&
        Be(
          "Active effect was not restored correctly - this is likely a Vue internal bug."
        ),
        ei(this),
        (z = t),
        ($e = o),
        (this.flags &= -3);
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let t = this.deps; t; t = t.nextDep) Fn(t);
      (this.deps = this.depsTail = void 0),
        ls(this),
        this.onStop && this.onStop(),
        (this.flags &= -2);
    }
  }
  trigger() {
    this.flags & 64
      ? sn.add(this)
      : this.scheduler
      ? this.scheduler()
      : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    gn(this) && this.run();
  }
  get dirty() {
    return gn(this);
  }
}
let Xs = 0,
  zt,
  Jt;
function Zs(e, t = !1) {
  if (((e.flags |= 8), t)) {
    (e.next = Jt), (Jt = e);
    return;
  }
  (e.next = zt), (zt = e);
}
function In() {
  Xs++;
}
function jn() {
  if (--Xs > 0) return;
  if (Jt) {
    let t = Jt;
    for (Jt = void 0; t; ) {
      const o = t.next;
      (t.next = void 0), (t.flags &= -9), (t = o);
    }
  }
  let e;
  for (; zt; ) {
    let t = zt;
    for (zt = void 0; t; ) {
      const o = t.next;
      if (((t.next = void 0), (t.flags &= -9), t.flags & 1))
        try {
          t.trigger();
        } catch (n) {
          e || (e = n);
        }
      t = o;
    }
  }
  if (e) throw e;
}
function qs(e) {
  for (let t = e.deps; t; t = t.nextDep)
    (t.version = -1),
      (t.prevActiveLink = t.dep.activeLink),
      (t.dep.activeLink = t);
}
function ei(e) {
  let t,
    o = e.depsTail,
    n = o;
  for (; n; ) {
    const s = n.prevDep;
    n.version === -1 ? (n === o && (o = s), Fn(n), Vr(n)) : (t = n),
      (n.dep.activeLink = n.prevActiveLink),
      (n.prevActiveLink = void 0),
      (n = s);
  }
  (e.deps = t), (e.depsTail = o);
}
function gn(e) {
  for (let t = e.deps; t; t = t.nextDep)
    if (
      t.dep.version !== t.version ||
      (t.dep.computed && (ti(t.dep.computed) || t.dep.version !== t.version))
    )
      return !0;
  return !!e._dirty;
}
function ti(e) {
  if (
    (e.flags & 4 && !(e.flags & 16)) ||
    ((e.flags &= -17), e.globalVersion === Qt)
  )
    return;
  e.globalVersion = Qt;
  const t = e.dep;
  if (((e.flags |= 2), t.version > 0 && !e.isSSR && e.deps && !gn(e))) {
    e.flags &= -3;
    return;
  }
  const o = z,
    n = $e;
  (z = e), ($e = !0);
  try {
    qs(e);
    const s = e.fn(e._value);
    (t.version === 0 || ft(s, e._value)) && ((e._value = s), t.version++);
  } catch (s) {
    throw (t.version++, s);
  } finally {
    (z = o), ($e = n), ei(e), (e.flags &= -3);
  }
}
function Fn(e, t = !1) {
  const { dep: o, prevSub: n, nextSub: s } = e;
  if (
    (n && ((n.nextSub = s), (e.prevSub = void 0)),
    s && ((s.prevSub = n), (e.nextSub = void 0)),
    process.env.NODE_ENV !== "production" &&
      o.subsHead === e &&
      (o.subsHead = s),
    o.subs === e && ((o.subs = n), !n && o.computed))
  ) {
    o.computed.flags &= -5;
    for (let i = o.computed.deps; i; i = i.nextDep) Fn(i, !0);
  }
  !t && !--o.sc && o.map && o.map.delete(o.key);
}
function Vr(e) {
  const { prevDep: t, nextDep: o } = e;
  t && ((t.nextDep = o), (e.prevDep = void 0)),
    o && ((o.prevDep = t), (e.nextDep = void 0));
}
let $e = !0;
const oi = [];
function qe() {
  oi.push($e), ($e = !1);
}
function et() {
  const e = oi.pop();
  $e = e === void 0 ? !0 : e;
}
function ls(e) {
  const { cleanup: t } = e;
  if (((e.cleanup = void 0), t)) {
    const o = z;
    z = void 0;
    try {
      t();
    } finally {
      z = o;
    }
  }
}
let Qt = 0;
class Dr {
  constructor(t, o) {
    (this.sub = t),
      (this.dep = o),
      (this.version = o.version),
      (this.nextDep =
        this.prevDep =
        this.nextSub =
        this.prevSub =
        this.prevActiveLink =
          void 0);
  }
}
class Un {
  constructor(t) {
    (this.computed = t),
      (this.version = 0),
      (this.activeLink = void 0),
      (this.subs = void 0),
      (this.map = void 0),
      (this.key = void 0),
      (this.sc = 0),
      process.env.NODE_ENV !== "production" && (this.subsHead = void 0);
  }
  track(t) {
    if (!z || !$e || z === this.computed) return;
    let o = this.activeLink;
    if (o === void 0 || o.sub !== z)
      (o = this.activeLink = new Dr(z, this)),
        z.deps
          ? ((o.prevDep = z.depsTail),
            (z.depsTail.nextDep = o),
            (z.depsTail = o))
          : (z.deps = z.depsTail = o),
        ni(o);
    else if (o.version === -1 && ((o.version = this.version), o.nextDep)) {
      const n = o.nextDep;
      (n.prevDep = o.prevDep),
        o.prevDep && (o.prevDep.nextDep = n),
        (o.prevDep = z.depsTail),
        (o.nextDep = void 0),
        (z.depsTail.nextDep = o),
        (z.depsTail = o),
        z.deps === o && (z.deps = n);
    }
    return (
      process.env.NODE_ENV !== "production" &&
        z.onTrack &&
        z.onTrack(
          ee(
            {
              effect: z,
            },
            t
          )
        ),
      o
    );
  }
  trigger(t) {
    this.version++, Qt++, this.notify(t);
  }
  notify(t) {
    In();
    try {
      if (process.env.NODE_ENV !== "production")
        for (let o = this.subsHead; o; o = o.nextSub)
          o.sub.onTrigger &&
            !(o.sub.flags & 8) &&
            o.sub.onTrigger(
              ee(
                {
                  effect: o.sub,
                },
                t
              )
            );
      for (let o = this.subs; o; o = o.prevSub)
        o.sub.notify() && o.sub.dep.notify();
    } finally {
      jn();
    }
  }
}
function ni(e) {
  if ((e.dep.sc++, e.sub.flags & 4)) {
    const t = e.dep.computed;
    if (t && !e.dep.subs) {
      t.flags |= 20;
      for (let n = t.deps; n; n = n.nextDep) ni(n);
    }
    const o = e.dep.subs;
    o !== e && ((e.prevSub = o), o && (o.nextSub = e)),
      process.env.NODE_ENV !== "production" &&
        e.dep.subsHead === void 0 &&
        (e.dep.subsHead = e),
      (e.dep.subs = e);
  }
}
const mn = /* @__PURE__ */ new WeakMap(),
  vt = Symbol(process.env.NODE_ENV !== "production" ? "Object iterate" : ""),
  _n = Symbol(process.env.NODE_ENV !== "production" ? "Map keys iterate" : ""),
  Xt = Symbol(process.env.NODE_ENV !== "production" ? "Array iterate" : "");
function se(e, t, o) {
  if ($e && z) {
    let n = mn.get(e);
    n || mn.set(e, (n = /* @__PURE__ */ new Map()));
    let s = n.get(o);
    s || (n.set(o, (s = new Un())), (s.map = n), (s.key = o)),
      process.env.NODE_ENV !== "production"
        ? s.track({
            target: e,
            type: t,
            key: o,
          })
        : s.track();
  }
}
function je(e, t, o, n, s, i) {
  const r = mn.get(e);
  if (!r) {
    Qt++;
    return;
  }
  const l = (a) => {
    a &&
      (process.env.NODE_ENV !== "production"
        ? a.trigger({
            target: e,
            type: t,
            key: o,
            newValue: n,
            oldValue: s,
            oldTarget: i,
          })
        : a.trigger());
  };
  if ((In(), t === "clear")) r.forEach(l);
  else {
    const a = $(e),
      p = a && kn(o);
    if (a && o === "length") {
      const d = Number(n);
      r.forEach((u, h) => {
        (h === "length" || h === Xt || (!He(h) && h >= d)) && l(u);
      });
    } else
      switch (
        ((o !== void 0 || r.has(void 0)) && l(r.get(o)), p && l(r.get(Xt)), t)
      ) {
        case "add":
          a ? p && l(r.get("length")) : (l(r.get(vt)), _t(e) && l(r.get(_n)));
          break;
        case "delete":
          a || (l(r.get(vt)), _t(e) && l(r.get(_n)));
          break;
        case "set":
          _t(e) && l(r.get(vt));
          break;
      }
  }
  jn();
}
function Ot(e) {
  const t = U(e);
  return t === e ? t : (se(t, "iterate", Xt), ge(e) ? t : t.map(ue));
}
function Ko(e) {
  return se((e = U(e)), "iterate", Xt), e;
}
const Sr = {
  __proto__: null,
  [Symbol.iterator]() {
    return rn(this, Symbol.iterator, ue);
  },
  concat(...e) {
    return Ot(this).concat(...e.map((t) => ($(t) ? Ot(t) : t)));
  },
  entries() {
    return rn(this, "entries", (e) => ((e[1] = ue(e[1])), e));
  },
  every(e, t) {
    return ze(this, "every", e, t, void 0, arguments);
  },
  filter(e, t) {
    return ze(this, "filter", e, t, (o) => o.map(ue), arguments);
  },
  find(e, t) {
    return ze(this, "find", e, t, ue, arguments);
  },
  findIndex(e, t) {
    return ze(this, "findIndex", e, t, void 0, arguments);
  },
  findLast(e, t) {
    return ze(this, "findLast", e, t, ue, arguments);
  },
  findLastIndex(e, t) {
    return ze(this, "findLastIndex", e, t, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(e, t) {
    return ze(this, "forEach", e, t, void 0, arguments);
  },
  includes(...e) {
    return ln(this, "includes", e);
  },
  indexOf(...e) {
    return ln(this, "indexOf", e);
  },
  join(e) {
    return Ot(this).join(e);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...e) {
    return ln(this, "lastIndexOf", e);
  },
  map(e, t) {
    return ze(this, "map", e, t, void 0, arguments);
  },
  pop() {
    return Ut(this, "pop");
  },
  push(...e) {
    return Ut(this, "push", e);
  },
  reduce(e, ...t) {
    return cs(this, "reduce", e, t);
  },
  reduceRight(e, ...t) {
    return cs(this, "reduceRight", e, t);
  },
  shift() {
    return Ut(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(e, t) {
    return ze(this, "some", e, t, void 0, arguments);
  },
  splice(...e) {
    return Ut(this, "splice", e);
  },
  toReversed() {
    return Ot(this).toReversed();
  },
  toSorted(e) {
    return Ot(this).toSorted(e);
  },
  toSpliced(...e) {
    return Ot(this).toSpliced(...e);
  },
  unshift(...e) {
    return Ut(this, "unshift", e);
  },
  values() {
    return rn(this, "values", ue);
  },
};
function rn(e, t, o) {
  const n = Ko(e),
    s = n[t]();
  return (
    n !== e &&
      !ge(e) &&
      ((s._next = s.next),
      (s.next = () => {
        const i = s._next();
        return i.value && (i.value = o(i.value)), i;
      })),
    s
  );
}
const Cr = Array.prototype;
function ze(e, t, o, n, s, i) {
  const r = Ko(e),
    l = r !== e && !ge(e),
    a = r[t];
  if (a !== Cr[t]) {
    const u = a.apply(e, i);
    return l ? ue(u) : u;
  }
  let p = o;
  r !== e &&
    (l
      ? (p = function (u, h) {
          return o.call(this, ue(u), h, e);
        })
      : o.length > 2 &&
        (p = function (u, h) {
          return o.call(this, u, h, e);
        }));
  const d = a.call(r, p, n);
  return l && s ? s(d) : d;
}
function cs(e, t, o, n) {
  const s = Ko(e);
  let i = o;
  return (
    s !== e &&
      (ge(e)
        ? o.length > 3 &&
          (i = function (r, l, a) {
            return o.call(this, r, l, a, e);
          })
        : (i = function (r, l, a) {
            return o.call(this, r, ue(l), a, e);
          })),
    s[t](i, ...n)
  );
}
function ln(e, t, o) {
  const n = U(e);
  se(n, "iterate", Xt);
  const s = n[t](...o);
  return (s === -1 || s === !1) && Do(o[0])
    ? ((o[0] = U(o[0])), n[t](...o))
    : s;
}
function Ut(e, t, o = []) {
  qe(), In();
  const n = U(e)[t].apply(e, o);
  return jn(), et(), n;
}
const Tr = /* @__PURE__ */ Ze("__proto__,__v_isRef,__isVue"),
  si = new Set(
    /* @__PURE__ */ Object.getOwnPropertyNames(Symbol)
      .filter((e) => e !== "arguments" && e !== "caller")
      .map((e) => Symbol[e])
      .filter(He)
  );
function $r(e) {
  He(e) || (e = String(e));
  const t = U(this);
  return se(t, "has", e), t.hasOwnProperty(e);
}
class ii {
  constructor(t = !1, o = !1) {
    (this._isReadonly = t), (this._isShallow = o);
  }
  get(t, o, n) {
    if (o === "__v_skip") return t.__v_skip;
    const s = this._isReadonly,
      i = this._isShallow;
    if (o === "__v_isReactive") return !s;
    if (o === "__v_isReadonly") return s;
    if (o === "__v_isShallow") return i;
    if (o === "__v_raw")
      return n === (s ? (i ? fi : ui) : i ? ai : ci).get(t) || // receiver is not the reactive proxy, but has the same prototype
        // this means the receiver is a user proxy of the reactive proxy
        Object.getPrototypeOf(t) === Object.getPrototypeOf(n)
        ? t
        : void 0;
    const r = $(t);
    if (!s) {
      let a;
      if (r && (a = Sr[o])) return a;
      if (o === "hasOwnProperty") return $r;
    }
    const l = Reflect.get(
      t,
      o,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      oe(t) ? t : n
    );
    return (He(o) ? si.has(o) : Tr(o)) || (s || se(t, "get", o), i)
      ? l
      : oe(l)
      ? r && kn(o)
        ? l
        : l.value
      : G(l)
      ? s
        ? di(l)
        : io(l)
      : l;
  }
}
class ri extends ii {
  constructor(t = !1) {
    super(!1, t);
  }
  set(t, o, n, s) {
    let i = t[o];
    if (!this._isShallow) {
      const a = Xe(i);
      if (
        (!ge(n) && !Xe(n) && ((i = U(i)), (n = U(n))), !$(t) && oe(i) && !oe(n))
      )
        return a ? !1 : ((i.value = n), !0);
    }
    const r = $(t) && kn(o) ? Number(o) < t.length : W(t, o),
      l = Reflect.set(t, o, n, oe(t) ? t : s);
    return (
      t === U(s) &&
        (r ? ft(n, i) && je(t, "set", o, n, i) : je(t, "add", o, n)),
      l
    );
  }
  deleteProperty(t, o) {
    const n = W(t, o),
      s = t[o],
      i = Reflect.deleteProperty(t, o);
    return i && n && je(t, "delete", o, void 0, s), i;
  }
  has(t, o) {
    const n = Reflect.has(t, o);
    return (!He(o) || !si.has(o)) && se(t, "has", o), n;
  }
  ownKeys(t) {
    return se(t, "iterate", $(t) ? "length" : vt), Reflect.ownKeys(t);
  }
}
class li extends ii {
  constructor(t = !1) {
    super(!0, t);
  }
  set(t, o) {
    return (
      process.env.NODE_ENV !== "production" &&
        Be(
          `Set operation on key "${String(o)}" failed: target is readonly.`,
          t
        ),
      !0
    );
  }
  deleteProperty(t, o) {
    return (
      process.env.NODE_ENV !== "production" &&
        Be(
          `Delete operation on key "${String(o)}" failed: target is readonly.`,
          t
        ),
      !0
    );
  }
}
const Ar = /* @__PURE__ */ new ri(),
  Pr = /* @__PURE__ */ new li(),
  kr = /* @__PURE__ */ new ri(!0),
  Rr = /* @__PURE__ */ new li(!0),
  vn = (e) => e,
  po = (e) => Reflect.getPrototypeOf(e);
function Mr(e, t, o) {
  return function (...n) {
    const s = this.__v_raw,
      i = U(s),
      r = _t(i),
      l = e === "entries" || (e === Symbol.iterator && r),
      a = e === "keys" && r,
      p = s[e](...n),
      d = o ? vn : t ? bn : ue;
    return (
      !t && se(i, "iterate", a ? _n : vt),
      {
        // iterator protocol
        next() {
          const { value: u, done: h } = p.next();
          return h
            ? { value: u, done: h }
            : {
                value: l ? [d(u[0]), d(u[1])] : d(u),
                done: h,
              };
        },
        // iterable protocol
        [Symbol.iterator]() {
          return this;
        },
      }
    );
  };
}
function ho(e) {
  return function (...t) {
    if (process.env.NODE_ENV !== "production") {
      const o = t[0] ? `on key "${t[0]}" ` : "";
      Be(`${Bo(e)} operation ${o}failed: target is readonly.`, U(this));
    }
    return e === "delete" ? !1 : e === "clear" ? void 0 : this;
  };
}
function Ir(e, t) {
  const o = {
    get(s) {
      const i = this.__v_raw,
        r = U(i),
        l = U(s);
      e || (ft(s, l) && se(r, "get", s), se(r, "get", l));
      const { has: a } = po(r),
        p = t ? vn : e ? bn : ue;
      if (a.call(r, s)) return p(i.get(s));
      if (a.call(r, l)) return p(i.get(l));
      i !== r && i.get(s);
    },
    get size() {
      const s = this.__v_raw;
      return !e && se(U(s), "iterate", vt), Reflect.get(s, "size", s);
    },
    has(s) {
      const i = this.__v_raw,
        r = U(i),
        l = U(s);
      return (
        e || (ft(s, l) && se(r, "has", s), se(r, "has", l)),
        s === l ? i.has(s) : i.has(s) || i.has(l)
      );
    },
    forEach(s, i) {
      const r = this,
        l = r.__v_raw,
        a = U(l),
        p = t ? vn : e ? bn : ue;
      return (
        !e && se(a, "iterate", vt),
        l.forEach((d, u) => s.call(i, p(d), p(u), r))
      );
    },
  };
  return (
    ee(
      o,
      e
        ? {
            add: ho("add"),
            set: ho("set"),
            delete: ho("delete"),
            clear: ho("clear"),
          }
        : {
            add(s) {
              !t && !ge(s) && !Xe(s) && (s = U(s));
              const i = U(this);
              return (
                po(i).has.call(i, s) || (i.add(s), je(i, "add", s, s)), this
              );
            },
            set(s, i) {
              !t && !ge(i) && !Xe(i) && (i = U(i));
              const r = U(this),
                { has: l, get: a } = po(r);
              let p = l.call(r, s);
              p
                ? process.env.NODE_ENV !== "production" && as(r, l, s)
                : ((s = U(s)), (p = l.call(r, s)));
              const d = a.call(r, s);
              return (
                r.set(s, i),
                p ? ft(i, d) && je(r, "set", s, i, d) : je(r, "add", s, i),
                this
              );
            },
            delete(s) {
              const i = U(this),
                { has: r, get: l } = po(i);
              let a = r.call(i, s);
              a
                ? process.env.NODE_ENV !== "production" && as(i, r, s)
                : ((s = U(s)), (a = r.call(i, s)));
              const p = l ? l.call(i, s) : void 0,
                d = i.delete(s);
              return a && je(i, "delete", s, void 0, p), d;
            },
            clear() {
              const s = U(this),
                i = s.size !== 0,
                r =
                  process.env.NODE_ENV !== "production"
                    ? _t(s)
                      ? new Map(s)
                      : new Set(s)
                    : void 0,
                l = s.clear();
              return i && je(s, "clear", void 0, void 0, r), l;
            },
          }
    ),
    ["keys", "values", "entries", Symbol.iterator].forEach((s) => {
      o[s] = Mr(s, e, t);
    }),
    o
  );
}
function Wo(e, t) {
  const o = Ir(e, t);
  return (n, s, i) =>
    s === "__v_isReactive"
      ? !e
      : s === "__v_isReadonly"
      ? e
      : s === "__v_raw"
      ? n
      : Reflect.get(W(o, s) && s in n ? o : n, s, i);
}
const jr = {
    get: /* @__PURE__ */ Wo(!1, !1),
  },
  Fr = {
    get: /* @__PURE__ */ Wo(!1, !0),
  },
  Ur = {
    get: /* @__PURE__ */ Wo(!0, !1),
  },
  Lr = {
    get: /* @__PURE__ */ Wo(!0, !0),
  };
function as(e, t, o) {
  const n = U(o);
  if (n !== o && t.call(e, n)) {
    const s = Pn(e);
    Be(
      `Reactive ${s} contains both the raw and reactive versions of the same object${
        s === "Map" ? " as keys" : ""
      }, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}
const ci = /* @__PURE__ */ new WeakMap(),
  ai = /* @__PURE__ */ new WeakMap(),
  ui = /* @__PURE__ */ new WeakMap(),
  fi = /* @__PURE__ */ new WeakMap();
function Hr(e) {
  switch (e) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function Br(e) {
  return e.__v_skip || !Object.isExtensible(e) ? 0 : Hr(Pn(e));
}
function io(e) {
  return Xe(e) ? e : zo(e, !1, Ar, jr, ci);
}
function Kr(e) {
  return zo(e, !1, kr, Fr, ai);
}
function di(e) {
  return zo(e, !0, Pr, Ur, ui);
}
function Fe(e) {
  return zo(e, !0, Rr, Lr, fi);
}
function zo(e, t, o, n, s) {
  if (!G(e))
    return (
      process.env.NODE_ENV !== "production" &&
        Be(`value cannot be made ${t ? "readonly" : "reactive"}: ${String(e)}`),
      e
    );
  if (e.__v_raw && !(t && e.__v_isReactive)) return e;
  const i = s.get(e);
  if (i) return i;
  const r = Br(e);
  if (r === 0) return e;
  const l = new Proxy(e, r === 2 ? n : o);
  return s.set(e, l), l;
}
function bt(e) {
  return Xe(e) ? bt(e.__v_raw) : !!(e && e.__v_isReactive);
}
function Xe(e) {
  return !!(e && e.__v_isReadonly);
}
function ge(e) {
  return !!(e && e.__v_isShallow);
}
function Do(e) {
  return e ? !!e.__v_raw : !1;
}
function U(e) {
  const t = e && e.__v_raw;
  return t ? U(t) : e;
}
function Wr(e) {
  return (
    !W(e, "__v_skip") && Object.isExtensible(e) && xo(e, "__v_skip", !0), e
  );
}
const ue = (e) => (G(e) ? io(e) : e),
  bn = (e) => (G(e) ? di(e) : e);
function oe(e) {
  return e ? e.__v_isRef === !0 : !1;
}
function So(e) {
  return zr(e, !1);
}
function zr(e, t) {
  return oe(e) ? e : new Jr(e, t);
}
class Jr {
  constructor(t, o) {
    (this.dep = new Un()),
      (this.__v_isRef = !0),
      (this.__v_isShallow = !1),
      (this._rawValue = o ? t : U(t)),
      (this._value = o ? t : ue(t)),
      (this.__v_isShallow = o);
  }
  get value() {
    return (
      process.env.NODE_ENV !== "production"
        ? this.dep.track({
            target: this,
            type: "get",
            key: "value",
          })
        : this.dep.track(),
      this._value
    );
  }
  set value(t) {
    const o = this._rawValue,
      n = this.__v_isShallow || ge(t) || Xe(t);
    (t = n ? t : U(t)),
      ft(t, o) &&
        ((this._rawValue = t),
        (this._value = n ? t : ue(t)),
        process.env.NODE_ENV !== "production"
          ? this.dep.trigger({
              target: this,
              type: "set",
              key: "value",
              newValue: t,
              oldValue: o,
            })
          : this.dep.trigger());
  }
}
function Pt(e) {
  return oe(e) ? e.value : e;
}
const Gr = {
  get: (e, t, o) => (t === "__v_raw" ? e : Pt(Reflect.get(e, t, o))),
  set: (e, t, o, n) => {
    const s = e[t];
    return oe(s) && !oe(o) ? ((s.value = o), !0) : Reflect.set(e, t, o, n);
  },
};
function pi(e) {
  return bt(e) ? e : new Proxy(e, Gr);
}
class Yr {
  constructor(t, o, n) {
    (this.fn = t),
      (this.setter = o),
      (this._value = void 0),
      (this.dep = new Un(this)),
      (this.__v_isRef = !0),
      (this.deps = void 0),
      (this.depsTail = void 0),
      (this.flags = 16),
      (this.globalVersion = Qt - 1),
      (this.next = void 0),
      (this.effect = this),
      (this.__v_isReadonly = !o),
      (this.isSSR = n);
  }
  /**
   * @internal
   */
  notify() {
    if (
      ((this.flags |= 16),
      !(this.flags & 8) && // avoid infinite self recursion
        z !== this)
    )
      return Zs(this, !0), !0;
    process.env.NODE_ENV;
  }
  get value() {
    const t =
      process.env.NODE_ENV !== "production"
        ? this.dep.track({
            target: this,
            type: "get",
            key: "value",
          })
        : this.dep.track();
    return ti(this), t && (t.version = this.dep.version), this._value;
  }
  set value(t) {
    this.setter
      ? this.setter(t)
      : process.env.NODE_ENV !== "production" &&
        Be("Write operation failed: computed value is readonly");
  }
}
function Qr(e, t, o = !1) {
  let n, s;
  I(e) ? (n = e) : ((n = e.get), (s = e.set));
  const i = new Yr(n, s, o);
  return process.env.NODE_ENV, i;
}
const go = {},
  Co = /* @__PURE__ */ new WeakMap();
let mt;
function Xr(e, t = !1, o = mt) {
  if (o) {
    let n = Co.get(o);
    n || Co.set(o, (n = [])), n.push(e);
  } else
    process.env.NODE_ENV !== "production" &&
      !t &&
      Be(
        "onWatcherCleanup() was called when there was no active watcher to associate with."
      );
}
function Zr(e, t, o = J) {
  const {
      immediate: n,
      deep: s,
      once: i,
      scheduler: r,
      augmentJob: l,
      call: a,
    } = o,
    p = (D) => {
      (o.onWarn || Be)(
        "Invalid watch source: ",
        D,
        "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types."
      );
    },
    d = (D) => (s ? D : ge(D) || s === !1 || s === 0 ? Ye(D, 1) : Ye(D));
  let u,
    h,
    m,
    N,
    C = !1,
    Q = !1;
  if (
    (oe(e)
      ? ((h = () => e.value), (C = ge(e)))
      : bt(e)
      ? ((h = () => d(e)), (C = !0))
      : $(e)
      ? ((Q = !0),
        (C = e.some((D) => bt(D) || ge(D))),
        (h = () =>
          e.map((D) => {
            if (oe(D)) return D.value;
            if (bt(D)) return d(D);
            if (I(D)) return a ? a(D, 2) : D();
            process.env.NODE_ENV !== "production" && p(D);
          })))
      : I(e)
      ? t
        ? (h = a ? () => a(e, 2) : e)
        : (h = () => {
            if (m) {
              qe();
              try {
                m();
              } finally {
                et();
              }
            }
            const D = mt;
            mt = u;
            try {
              return a ? a(e, 3, [N]) : e(N);
            } finally {
              mt = D;
            }
          })
      : ((h = ie), process.env.NODE_ENV !== "production" && p(e)),
    t && s)
  ) {
    const D = h,
      re = s === !0 ? 1 / 0 : s;
    h = () => Ye(D(), re);
  }
  const T = xr(),
    L = () => {
      u.stop(), T && T.active && $n(T.effects, u);
    };
  if (i && t) {
    const D = t;
    t = (...re) => {
      D(...re), L();
    };
  }
  let A = Q ? new Array(e.length).fill(go) : go;
  const te = (D) => {
    if (!(!(u.flags & 1) || (!u.dirty && !D)))
      if (t) {
        const re = u.run();
        if (s || C || (Q ? re.some((De, ce) => ft(De, A[ce])) : ft(re, A))) {
          m && m();
          const De = mt;
          mt = u;
          try {
            const ce = [
              re,
              // pass undefined as the old value when it's changed for the first time
              A === go ? void 0 : Q && A[0] === go ? [] : A,
              N,
            ];
            a
              ? a(t, 3, ce)
              : // @ts-expect-error
                t(...ce),
              (A = re);
          } finally {
            mt = De;
          }
        }
      } else u.run();
  };
  return (
    l && l(te),
    (u = new Qs(h)),
    (u.scheduler = r ? () => r(te, !1) : te),
    (N = (D) => Xr(D, !1, u)),
    (m = u.onStop =
      () => {
        const D = Co.get(u);
        if (D) {
          if (a) a(D, 4);
          else for (const re of D) re();
          Co.delete(u);
        }
      }),
    process.env.NODE_ENV !== "production" &&
      ((u.onTrack = o.onTrack), (u.onTrigger = o.onTrigger)),
    t ? (n ? te(!0) : (A = u.run())) : r ? r(te.bind(null, !0), !0) : u.run(),
    (L.pause = u.pause.bind(u)),
    (L.resume = u.resume.bind(u)),
    (L.stop = L),
    L
  );
}
function Ye(e, t = 1 / 0, o) {
  if (
    t <= 0 ||
    !G(e) ||
    e.__v_skip ||
    ((o = o || /* @__PURE__ */ new Set()), o.has(e))
  )
    return e;
  if ((o.add(e), t--, oe(e))) Ye(e.value, t, o);
  else if ($(e)) for (let n = 0; n < e.length; n++) Ye(e[n], t, o);
  else if (Uo(e) || _t(e))
    e.forEach((n) => {
      Ye(n, t, o);
    });
  else if (Lo(e)) {
    for (const n in e) Ye(e[n], t, o);
    for (const n of Object.getOwnPropertySymbols(e))
      Object.prototype.propertyIsEnumerable.call(e, n) && Ye(e[n], t, o);
  }
  return e;
}
/**
 * @vue/runtime-core v3.5.13
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
const yt = [];
function mo(e) {
  yt.push(e);
}
function _o() {
  yt.pop();
}
let cn = !1;
function O(e, ...t) {
  if (cn) return;
  (cn = !0), qe();
  const o = yt.length ? yt[yt.length - 1].component : null,
    n = o && o.appContext.config.warnHandler,
    s = qr();
  if (n)
    Rt(n, o, 11, [
      // eslint-disable-next-line no-restricted-syntax
      e +
        t
          .map((i) => {
            var r, l;
            return (l = (r = i.toString) == null ? void 0 : r.call(i)) != null
              ? l
              : JSON.stringify(i);
          })
          .join(""),
      o && o.proxy,
      s.map(({ vnode: i }) => `at <${qo(o, i.type)}>`).join(`
`),
      s,
    ]);
  else {
    const i = [`[Vue warn]: ${e}`, ...t];
    s.length &&
      i.push(
        `
`,
        ...el(s)
      ),
      console.warn(...i);
  }
  et(), (cn = !1);
}
function qr() {
  let e = yt[yt.length - 1];
  if (!e) return [];
  const t = [];
  for (; e; ) {
    const o = t[0];
    o && o.vnode === e
      ? o.recurseCount++
      : t.push({
          vnode: e,
          recurseCount: 0,
        });
    const n = e.component && e.component.parent;
    e = n && n.vnode;
  }
  return t;
}
function el(e) {
  const t = [];
  return (
    e.forEach((o, n) => {
      t.push(
        ...(n === 0
          ? []
          : [
              `
`,
            ]),
        ...tl(o)
      );
    }),
    t
  );
}
function tl({ vnode: e, recurseCount: t }) {
  const o = t > 0 ? `... (${t} recursive calls)` : "",
    n = e.component ? e.component.parent == null : !1,
    s = ` at <${qo(e.component, e.type, n)}`,
    i = ">" + o;
  return e.props ? [s, ...ol(e.props), i] : [s + i];
}
function ol(e) {
  const t = [],
    o = Object.keys(e);
  return (
    o.slice(0, 3).forEach((n) => {
      t.push(...hi(n, e[n]));
    }),
    o.length > 3 && t.push(" ..."),
    t
  );
}
function hi(e, t, o) {
  return q(t)
    ? ((t = JSON.stringify(t)), o ? t : [`${e}=${t}`])
    : typeof t == "number" || typeof t == "boolean" || t == null
    ? o
      ? t
      : [`${e}=${t}`]
    : oe(t)
    ? ((t = hi(e, U(t.value), !0)), o ? t : [`${e}=Ref<`, t, ">"])
    : I(t)
    ? [`${e}=fn${t.name ? `<${t.name}>` : ""}`]
    : ((t = U(t)), o ? t : [`${e}=`, t]);
}
const Ln = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  0: "setup function",
  1: "render function",
  2: "watcher getter",
  3: "watcher callback",
  4: "watcher cleanup function",
  5: "native event handler",
  6: "component event handler",
  7: "vnode hook",
  8: "directive hook",
  9: "transition hook",
  10: "app errorHandler",
  11: "app warnHandler",
  12: "ref function",
  13: "async component loader",
  14: "scheduler flush",
  15: "component update",
  16: "app unmount cleanup function",
};
function Rt(e, t, o, n) {
  try {
    return n ? e(...n) : e();
  } catch (s) {
    ro(s, t, o);
  }
}
function Ke(e, t, o, n) {
  if (I(e)) {
    const s = Rt(e, t, o, n);
    return (
      s &&
        An(s) &&
        s.catch((i) => {
          ro(i, t, o);
        }),
      s
    );
  }
  if ($(e)) {
    const s = [];
    for (let i = 0; i < e.length; i++) s.push(Ke(e[i], t, o, n));
    return s;
  } else
    process.env.NODE_ENV !== "production" &&
      O(
        `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof e}`
      );
}
function ro(e, t, o, n = !0) {
  const s = t ? t.vnode : null,
    { errorHandler: i, throwUnhandledErrorInProduction: r } =
      (t && t.appContext.config) || J;
  if (t) {
    let l = t.parent;
    const a = t.proxy,
      p =
        process.env.NODE_ENV !== "production"
          ? Ln[o]
          : `https://vuejs.org/error-reference/#runtime-${o}`;
    for (; l; ) {
      const d = l.ec;
      if (d) {
        for (let u = 0; u < d.length; u++) if (d[u](e, a, p) === !1) return;
      }
      l = l.parent;
    }
    if (i) {
      qe(), Rt(i, null, 10, [e, a, p]), et();
      return;
    }
  }
  nl(e, o, s, n, r);
}
function nl(e, t, o, n = !0, s = !1) {
  if (process.env.NODE_ENV !== "production") {
    const i = Ln[t];
    if (
      (o && mo(o),
      O(`Unhandled error${i ? ` during execution of ${i}` : ""}`),
      o && _o(),
      n)
    )
      throw e;
    console.error(e);
  } else {
    if (s) throw e;
    console.error(e);
  }
}
const pe = [];
let Ie = -1;
const Tt = [];
let rt = null,
  St = 0;
const gi = /* @__PURE__ */ Promise.resolve();
let To = null;
const sl = 100;
function Hn(e) {
  const t = To || gi;
  return e ? t.then(this ? e.bind(this) : e) : t;
}
function il(e) {
  let t = Ie + 1,
    o = pe.length;
  for (; t < o; ) {
    const n = (t + o) >>> 1,
      s = pe[n],
      i = Zt(s);
    i < e || (i === e && s.flags & 2) ? (t = n + 1) : (o = n);
  }
  return t;
}
function Jo(e) {
  if (!(e.flags & 1)) {
    const t = Zt(e),
      o = pe[pe.length - 1];
    !o || // fast path when the job id is larger than the tail
    (!(e.flags & 2) && t >= Zt(o))
      ? pe.push(e)
      : pe.splice(il(t), 0, e),
      (e.flags |= 1),
      mi();
  }
}
function mi() {
  To || (To = gi.then(bi));
}
function _i(e) {
  $(e)
    ? Tt.push(...e)
    : rt && e.id === -1
    ? rt.splice(St + 1, 0, e)
    : e.flags & 1 || (Tt.push(e), (e.flags |= 1)),
    mi();
}
function us(e, t, o = Ie + 1) {
  for (
    process.env.NODE_ENV !== "production" &&
    (t = t || /* @__PURE__ */ new Map());
    o < pe.length;
    o++
  ) {
    const n = pe[o];
    if (n && n.flags & 2) {
      if (
        (e && n.id !== e.uid) ||
        (process.env.NODE_ENV !== "production" && Bn(t, n))
      )
        continue;
      pe.splice(o, 1),
        o--,
        n.flags & 4 && (n.flags &= -2),
        n(),
        n.flags & 4 || (n.flags &= -2);
    }
  }
}
function vi(e) {
  if (Tt.length) {
    const t = [...new Set(Tt)].sort((o, n) => Zt(o) - Zt(n));
    if (((Tt.length = 0), rt)) {
      rt.push(...t);
      return;
    }
    for (
      rt = t,
        process.env.NODE_ENV !== "production" &&
          (e = e || /* @__PURE__ */ new Map()),
        St = 0;
      St < rt.length;
      St++
    ) {
      const o = rt[St];
      (process.env.NODE_ENV !== "production" && Bn(e, o)) ||
        (o.flags & 4 && (o.flags &= -2), o.flags & 8 || o(), (o.flags &= -2));
    }
    (rt = null), (St = 0);
  }
}
const Zt = (e) => (e.id == null ? (e.flags & 2 ? -1 : 1 / 0) : e.id);
function bi(e) {
  process.env.NODE_ENV !== "production" && (e = e || /* @__PURE__ */ new Map());
  const t = process.env.NODE_ENV !== "production" ? (o) => Bn(e, o) : ie;
  try {
    for (Ie = 0; Ie < pe.length; Ie++) {
      const o = pe[Ie];
      if (o && !(o.flags & 8)) {
        if (process.env.NODE_ENV !== "production" && t(o)) continue;
        o.flags & 4 && (o.flags &= -2),
          Rt(o, o.i, o.i ? 15 : 14),
          o.flags & 4 || (o.flags &= -2);
      }
    }
  } finally {
    for (; Ie < pe.length; Ie++) {
      const o = pe[Ie];
      o && (o.flags &= -2);
    }
    (Ie = -1),
      (pe.length = 0),
      vi(e),
      (To = null),
      (pe.length || Tt.length) && bi(e);
  }
}
function Bn(e, t) {
  const o = e.get(t) || 0;
  if (o > sl) {
    const n = t.i,
      s = n && qi(n.type);
    return (
      ro(
        `Maximum recursive updates exceeded${
          s ? ` in component <${s}>` : ""
        }. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
        null,
        10
      ),
      !0
    );
  }
  return e.set(t, o + 1), !1;
}
let Ue = !1;
const vo = /* @__PURE__ */ new Map();
process.env.NODE_ENV !== "production" &&
  (so().__VUE_HMR_RUNTIME__ = {
    createRecord: an(yi),
    rerender: an(cl),
    reload: an(al),
  });
const Nt = /* @__PURE__ */ new Map();
function rl(e) {
  const t = e.type.__hmrId;
  let o = Nt.get(t);
  o || (yi(t, e.type), (o = Nt.get(t))), o.instances.add(e);
}
function ll(e) {
  Nt.get(e.type.__hmrId).instances.delete(e);
}
function yi(e, t) {
  return Nt.has(e)
    ? !1
    : (Nt.set(e, {
        initialDef: $o(t),
        instances: /* @__PURE__ */ new Set(),
      }),
      !0);
}
function $o(e) {
  return er(e) ? e.__vccOpts : e;
}
function cl(e, t) {
  const o = Nt.get(e);
  o &&
    ((o.initialDef.render = t),
    [...o.instances].forEach((n) => {
      t && ((n.render = t), ($o(n.type).render = t)),
        (n.renderCache = []),
        (Ue = !0),
        n.update(),
        (Ue = !1);
    }));
}
function al(e, t) {
  const o = Nt.get(e);
  if (!o) return;
  (t = $o(t)), fs(o.initialDef, t);
  const n = [...o.instances];
  for (let s = 0; s < n.length; s++) {
    const i = n[s],
      r = $o(i.type);
    let l = vo.get(r);
    l ||
      (r !== o.initialDef && fs(r, t),
      vo.set(r, (l = /* @__PURE__ */ new Set()))),
      l.add(i),
      i.appContext.propsCache.delete(i.type),
      i.appContext.emitsCache.delete(i.type),
      i.appContext.optionsCache.delete(i.type),
      i.ceReload
        ? (l.add(i), i.ceReload(t.styles), l.delete(i))
        : i.parent
        ? Jo(() => {
            (Ue = !0), i.parent.update(), (Ue = !1), l.delete(i);
          })
        : i.appContext.reload
        ? i.appContext.reload()
        : typeof window < "u"
        ? window.location.reload()
        : console.warn(
            "[HMR] Root or manually mounted instance modified. Full reload required."
          ),
      i.root.ce && i !== i.root && i.root.ce._removeChildStyle(r);
  }
  _i(() => {
    vo.clear();
  });
}
function fs(e, t) {
  ee(e, t);
  for (const o in e) o !== "__file" && !(o in t) && delete e[o];
}
function an(e) {
  return (t, o) => {
    try {
      return e(t, o);
    } catch (n) {
      console.error(n),
        console.warn(
          "[HMR] Something went wrong during Vue component hot-reload. Full reload required."
        );
    }
  };
}
let Te,
  Bt = [],
  yn = !1;
function lo(e, ...t) {
  Te ? Te.emit(e, ...t) : yn || Bt.push({ event: e, args: t });
}
function Kn(e, t) {
  var o, n;
  (Te = e),
    Te
      ? ((Te.enabled = !0),
        Bt.forEach(({ event: s, args: i }) => Te.emit(s, ...i)),
        (Bt = []))
      : /* handle late devtools injection - only do this if we are in an actual */ /* browser environment to avoid the timer handle stalling test runner exit */ /* (#4815) */ typeof window <
          "u" && // some envs mock window but not fully
        window.HTMLElement && // also exclude jsdom
        // eslint-disable-next-line no-restricted-syntax
        !(
          (n = (o = window.navigator) == null ? void 0 : o.userAgent) != null &&
          n.includes("jsdom")
        )
      ? ((t.__VUE_DEVTOOLS_HOOK_REPLAY__ =
          t.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((i) => {
          Kn(i, t);
        }),
        setTimeout(() => {
          Te || ((t.__VUE_DEVTOOLS_HOOK_REPLAY__ = null), (yn = !0), (Bt = []));
        }, 3e3))
      : ((yn = !0), (Bt = []));
}
function ul(e, t) {
  lo("app:init", e, t, {
    Fragment: Z,
    Text: co,
    Comment: xe,
    Static: Eo,
  });
}
function fl(e) {
  lo("app:unmount", e);
}
const dl = /* @__PURE__ */ Wn(
    "component:added"
    /* COMPONENT_ADDED */
  ),
  Ei = /* @__PURE__ */ Wn(
    "component:updated"
    /* COMPONENT_UPDATED */
  ),
  pl = /* @__PURE__ */ Wn(
    "component:removed"
    /* COMPONENT_REMOVED */
  ),
  hl = (e) => {
    Te &&
      typeof Te.cleanupBuffer == "function" && // remove the component if it wasn't buffered
      !Te.cleanupBuffer(e) &&
      pl(e);
  };
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function Wn(e) {
  return (t) => {
    lo(e, t.appContext.app, t.uid, t.parent ? t.parent.uid : void 0, t);
  };
}
const gl = /* @__PURE__ */ Ni(
    "perf:start"
    /* PERFORMANCE_START */
  ),
  ml = /* @__PURE__ */ Ni(
    "perf:end"
    /* PERFORMANCE_END */
  );
function Ni(e) {
  return (t, o, n) => {
    lo(e, t.appContext.app, t.uid, t, o, n);
  };
}
function _l(e, t, o) {
  lo("component:emit", e.appContext.app, e, t, o);
}
let he = null,
  wi = null;
function Ao(e) {
  const t = he;
  return (he = e), (wi = (e && e.type.__scopeId) || null), t;
}
function vl(e, t = he, o) {
  if (!t || e._n) return e;
  const n = (...s) => {
    n._d && ws(-1);
    const i = Ao(t);
    let r;
    try {
      r = e(...s);
    } finally {
      Ao(i), n._d && ws(1);
    }
    return process.env.NODE_ENV !== "production" && Ei(t), r;
  };
  return (n._n = !0), (n._c = !0), (n._d = !0), n;
}
function Oi(e) {
  lr(e) && O("Do not use built-in directive ids as custom directive id: " + e);
}
function ne(e, t) {
  if (he === null)
    return (
      process.env.NODE_ENV !== "production" &&
        O("withDirectives can only be used inside render functions."),
      e
    );
  const o = Zo(he),
    n = e.dirs || (e.dirs = []);
  for (let s = 0; s < t.length; s++) {
    let [i, r, l, a = J] = t[s];
    i &&
      (I(i) &&
        (i = {
          mounted: i,
          updated: i,
        }),
      i.deep && Ye(r),
      n.push({
        dir: i,
        instance: o,
        value: r,
        oldValue: void 0,
        arg: l,
        modifiers: a,
      }));
  }
  return e;
}
function pt(e, t, o, n) {
  const s = e.dirs,
    i = t && t.dirs;
  for (let r = 0; r < s.length; r++) {
    const l = s[r];
    i && (l.oldValue = i[r].value);
    let a = l.dir[n];
    a && (qe(), Ke(a, o, 8, [e.el, l, e, t]), et());
  }
}
const bl = Symbol("_vte"),
  yl = (e) => e.__isTeleport;
function zn(e, t) {
  e.shapeFlag & 6 && e.component
    ? ((e.transition = t), zn(e.component.subTree, t))
    : e.shapeFlag & 128
    ? ((e.ssContent.transition = t.clone(e.ssContent)),
      (e.ssFallback.transition = t.clone(e.ssFallback)))
    : (e.transition = t);
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function El(e, t) {
  return I(e)
    ? // #8236: extend call and options.name access are considered side-effects
      // by Rollup, so we have to wrap it in a pure-annotated IIFE.
      ee({ name: e.name }, t, { setup: e })
    : e;
}
function xi(e) {
  e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0];
}
const Nl = /* @__PURE__ */ new WeakSet();
function Po(e, t, o, n, s = !1) {
  if ($(e)) {
    e.forEach((N, C) => Po(N, t && ($(t) ? t[C] : t), o, n, s));
    return;
  }
  if (Gt(n) && !s) {
    n.shapeFlag & 512 &&
      n.type.__asyncResolved &&
      n.component.subTree.component &&
      Po(e, t, o, n.component.subTree);
    return;
  }
  const i = n.shapeFlag & 4 ? Zo(n.component) : n.el,
    r = s ? null : i,
    { i: l, r: a } = e;
  if (process.env.NODE_ENV !== "production" && !l) {
    O(
      "Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function."
    );
    return;
  }
  const p = t && t.r,
    d = l.refs === J ? (l.refs = {}) : l.refs,
    u = l.setupState,
    h = U(u),
    m =
      u === J
        ? () => !1
        : (N) =>
            process.env.NODE_ENV !== "production" &&
            (W(h, N) &&
              !oe(h[N]) &&
              O(
                `Template ref "${N}" used on a non-ref value. It will not work in the production build.`
              ),
            Nl.has(h[N]))
              ? !1
              : W(h, N);
  if (
    (p != null &&
      p !== a &&
      (q(p)
        ? ((d[p] = null), m(p) && (u[p] = null))
        : oe(p) && (p.value = null)),
    I(a))
  )
    Rt(a, l, 12, [r, d]);
  else {
    const N = q(a),
      C = oe(a);
    if (N || C) {
      const Q = () => {
        if (e.f) {
          const T = N ? (m(a) ? u[a] : d[a]) : a.value;
          s
            ? $(T) && $n(T, i)
            : $(T)
            ? T.includes(i) || T.push(i)
            : N
            ? ((d[a] = [i]), m(a) && (u[a] = d[a]))
            : ((a.value = [i]), e.k && (d[e.k] = a.value));
        } else
          N
            ? ((d[a] = r), m(a) && (u[a] = r))
            : C
            ? ((a.value = r), e.k && (d[e.k] = r))
            : process.env.NODE_ENV !== "production" &&
              O("Invalid template ref type:", a, `(${typeof a})`);
      };
      r ? ((Q.id = -1), Ee(Q, o)) : Q();
    } else
      process.env.NODE_ENV !== "production" &&
        O("Invalid template ref type:", a, `(${typeof a})`);
  }
}
so().requestIdleCallback;
so().cancelIdleCallback;
const Gt = (e) => !!e.type.__asyncLoader,
  Jn = (e) => e.type.__isKeepAlive;
function wl(e, t) {
  Vi(e, "a", t);
}
function Ol(e, t) {
  Vi(e, "da", t);
}
function Vi(e, t, o = le) {
  const n =
    e.__wdc ||
    (e.__wdc = () => {
      let s = o;
      for (; s; ) {
        if (s.isDeactivated) return;
        s = s.parent;
      }
      return e();
    });
  if ((Go(t, n, o), o)) {
    let s = o.parent;
    for (; s && s.parent; )
      Jn(s.parent.vnode) && xl(n, t, o, s), (s = s.parent);
  }
}
function xl(e, t, o, n) {
  const s = Go(
    t,
    e,
    n,
    !0
    /* prepend */
  );
  Di(() => {
    $n(n[t], s);
  }, o);
}
function Go(e, t, o = le, n = !1) {
  if (o) {
    const s = o[e] || (o[e] = []),
      i =
        t.__weh ||
        (t.__weh = (...r) => {
          qe();
          const l = ao(o),
            a = Ke(t, o, e, r);
          return l(), et(), a;
        });
    return n ? s.unshift(i) : s.push(i), i;
  } else if (process.env.NODE_ENV !== "production") {
    const s = gt(Ln[e].replace(/ hook$/, ""));
    O(
      `${s} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
    );
  }
}
const tt =
    (e) =>
    (t, o = le) => {
      (!eo || e === "sp") && Go(e, (...n) => t(...n), o);
    },
  Vl = tt("bm"),
  Yo = tt("m"),
  Dl = tt("bu"),
  Sl = tt("u"),
  Cl = tt("bum"),
  Di = tt("um"),
  Tl = tt("sp"),
  $l = tt("rtg"),
  Al = tt("rtc");
function Pl(e, t = le) {
  Go("ec", e, t);
}
const kl = Symbol.for("v-ndc");
function ae(e, t, o, n) {
  let s;
  const i = o,
    r = $(e);
  if (r || q(e)) {
    const l = r && bt(e);
    let a = !1;
    l && ((a = !ge(e)), (e = Ko(e))), (s = new Array(e.length));
    for (let p = 0, d = e.length; p < d; p++)
      s[p] = t(a ? ue(e[p]) : e[p], p, void 0, i);
  } else if (typeof e == "number") {
    process.env.NODE_ENV !== "production" &&
      !Number.isInteger(e) &&
      O(`The v-for range expect an integer value but got ${e}.`),
      (s = new Array(e));
    for (let l = 0; l < e; l++) s[l] = t(l + 1, l, void 0, i);
  } else if (G(e))
    if (e[Symbol.iterator]) s = Array.from(e, (l, a) => t(l, a, void 0, i));
    else {
      const l = Object.keys(e);
      s = new Array(l.length);
      for (let a = 0, p = l.length; a < p; a++) {
        const d = l[a];
        s[a] = t(e[d], d, a, i);
      }
    }
  else s = [];
  return s;
}
const En = (e) => (e ? (Xi(e) ? Zo(e) : En(e.parent)) : null),
  Et =
    // Move PURE marker to new line to workaround compiler discarding it
    // due to type annotation
    /* @__PURE__ */ ee(/* @__PURE__ */ Object.create(null), {
      $: (e) => e,
      $el: (e) => e.vnode.el,
      $data: (e) => e.data,
      $props: (e) =>
        process.env.NODE_ENV !== "production" ? Fe(e.props) : e.props,
      $attrs: (e) =>
        process.env.NODE_ENV !== "production" ? Fe(e.attrs) : e.attrs,
      $slots: (e) =>
        process.env.NODE_ENV !== "production" ? Fe(e.slots) : e.slots,
      $refs: (e) =>
        process.env.NODE_ENV !== "production" ? Fe(e.refs) : e.refs,
      $parent: (e) => En(e.parent),
      $root: (e) => En(e.root),
      $host: (e) => e.ce,
      $emit: (e) => e.emit,
      $options: (e) => Ti(e),
      $forceUpdate: (e) =>
        e.f ||
        (e.f = () => {
          Jo(e.update);
        }),
      $nextTick: (e) => e.n || (e.n = Hn.bind(e.proxy)),
      $watch: (e) => pc.bind(e),
    }),
  Gn = (e) => e === "_" || e === "$",
  un = (e, t) => e !== J && !e.__isScriptSetup && W(e, t),
  Si = {
    get({ _: e }, t) {
      if (t === "__v_skip") return !0;
      const {
        ctx: o,
        setupState: n,
        data: s,
        props: i,
        accessCache: r,
        type: l,
        appContext: a,
      } = e;
      if (process.env.NODE_ENV !== "production" && t === "__isVue") return !0;
      let p;
      if (t[0] !== "$") {
        const m = r[t];
        if (m !== void 0)
          switch (m) {
            case 1:
              return n[t];
            case 2:
              return s[t];
            case 4:
              return o[t];
            case 3:
              return i[t];
          }
        else {
          if (un(n, t)) return (r[t] = 1), n[t];
          if (s !== J && W(s, t)) return (r[t] = 2), s[t];
          if (
            // only cache other properties when instance has declared (thus stable)
            // props
            (p = e.propsOptions[0]) &&
            W(p, t)
          )
            return (r[t] = 3), i[t];
          if (o !== J && W(o, t)) return (r[t] = 4), o[t];
          Nn && (r[t] = 0);
        }
      }
      const d = Et[t];
      let u, h;
      if (d)
        return (
          t === "$attrs"
            ? (se(e.attrs, "get", ""),
              process.env.NODE_ENV !== "production" && Mo())
            : process.env.NODE_ENV !== "production" &&
              t === "$slots" &&
              se(e, "get", t),
          d(e)
        );
      if (
        // css module (injected by vue-loader)
        (u = l.__cssModules) &&
        (u = u[t])
      )
        return u;
      if (o !== J && W(o, t)) return (r[t] = 4), o[t];
      if (
        // global properties
        ((h = a.config.globalProperties), W(h, t))
      )
        return h[t];
      process.env.NODE_ENV !== "production" &&
        he &&
        (!q(t) || // #1091 avoid internal isRef/isVNode checks on component instance leading
          // to infinite warning loop
          t.indexOf("__v") !== 0) &&
        (s !== J && Gn(t[0]) && W(s, t)
          ? O(
              `Property ${JSON.stringify(
                t
              )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
            )
          : e === he &&
            O(
              `Property ${JSON.stringify(
                t
              )} was accessed during render but is not defined on instance.`
            ));
    },
    set({ _: e }, t, o) {
      const { data: n, setupState: s, ctx: i } = e;
      return un(s, t)
        ? ((s[t] = o), !0)
        : process.env.NODE_ENV !== "production" && s.__isScriptSetup && W(s, t)
        ? (O(`Cannot mutate <script setup> binding "${t}" from Options API.`),
          !1)
        : n !== J && W(n, t)
        ? ((n[t] = o), !0)
        : W(e.props, t)
        ? (process.env.NODE_ENV !== "production" &&
            O(`Attempting to mutate prop "${t}". Props are readonly.`),
          !1)
        : t[0] === "$" && t.slice(1) in e
        ? (process.env.NODE_ENV !== "production" &&
            O(
              `Attempting to mutate public property "${t}". Properties starting with $ are reserved and readonly.`
            ),
          !1)
        : (process.env.NODE_ENV !== "production" &&
          t in e.appContext.config.globalProperties
            ? Object.defineProperty(i, t, {
                enumerable: !0,
                configurable: !0,
                value: o,
              })
            : (i[t] = o),
          !0);
    },
    has(
      {
        _: {
          data: e,
          setupState: t,
          accessCache: o,
          ctx: n,
          appContext: s,
          propsOptions: i,
        },
      },
      r
    ) {
      let l;
      return (
        !!o[r] ||
        (e !== J && W(e, r)) ||
        un(t, r) ||
        ((l = i[0]) && W(l, r)) ||
        W(n, r) ||
        W(Et, r) ||
        W(s.config.globalProperties, r)
      );
    },
    defineProperty(e, t, o) {
      return (
        o.get != null
          ? (e._.accessCache[t] = 0)
          : W(o, "value") && this.set(e, t, o.value, null),
        Reflect.defineProperty(e, t, o)
      );
    },
  };
process.env.NODE_ENV !== "production" &&
  (Si.ownKeys = (e) => (
    O(
      "Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."
    ),
    Reflect.ownKeys(e)
  ));
function Rl(e) {
  const t = {};
  return (
    Object.defineProperty(t, "_", {
      configurable: !0,
      enumerable: !1,
      get: () => e,
    }),
    Object.keys(Et).forEach((o) => {
      Object.defineProperty(t, o, {
        configurable: !0,
        enumerable: !1,
        get: () => Et[o](e),
        // intercepted by the proxy so no need for implementation,
        // but needed to prevent set errors
        set: ie,
      });
    }),
    t
  );
}
function Ml(e) {
  const {
    ctx: t,
    propsOptions: [o],
  } = e;
  o &&
    Object.keys(o).forEach((n) => {
      Object.defineProperty(t, n, {
        enumerable: !0,
        configurable: !0,
        get: () => e.props[n],
        set: ie,
      });
    });
}
function Il(e) {
  const { ctx: t, setupState: o } = e;
  Object.keys(U(o)).forEach((n) => {
    if (!o.__isScriptSetup) {
      if (Gn(n[0])) {
        O(
          `setup() return property ${JSON.stringify(
            n
          )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
        );
        return;
      }
      Object.defineProperty(t, n, {
        enumerable: !0,
        configurable: !0,
        get: () => o[n],
        set: ie,
      });
    }
  });
}
function ds(e) {
  return $(e) ? e.reduce((t, o) => ((t[o] = null), t), {}) : e;
}
function jl() {
  const e = /* @__PURE__ */ Object.create(null);
  return (t, o) => {
    e[o]
      ? O(`${t} property "${o}" is already defined in ${e[o]}.`)
      : (e[o] = t);
  };
}
let Nn = !0;
function Fl(e) {
  const t = Ti(e),
    o = e.proxy,
    n = e.ctx;
  (Nn = !1), t.beforeCreate && ps(t.beforeCreate, e, "bc");
  const {
      // state
      data: s,
      computed: i,
      methods: r,
      watch: l,
      provide: a,
      inject: p,
      // lifecycle
      created: d,
      beforeMount: u,
      mounted: h,
      beforeUpdate: m,
      updated: N,
      activated: C,
      deactivated: Q,
      beforeDestroy: T,
      beforeUnmount: L,
      destroyed: A,
      unmounted: te,
      render: D,
      renderTracked: re,
      renderTriggered: De,
      errorCaptured: ce,
      serverPrefetch: me,
      // public API
      expose: We,
      inheritAttrs: ot,
      // assets
      components: Se,
      directives: uo,
      filters: es,
    } = t,
    nt = process.env.NODE_ENV !== "production" ? jl() : null;
  if (process.env.NODE_ENV !== "production") {
    const [B] = e.propsOptions;
    if (B) for (const H in B) nt("Props", H);
  }
  if ((p && Ul(p, n, nt), r))
    for (const B in r) {
      const H = r[B];
      I(H)
        ? (process.env.NODE_ENV !== "production"
            ? Object.defineProperty(n, B, {
                value: H.bind(o),
                configurable: !0,
                enumerable: !0,
                writable: !0,
              })
            : (n[B] = H.bind(o)),
          process.env.NODE_ENV !== "production" && nt("Methods", B))
        : process.env.NODE_ENV !== "production" &&
          O(
            `Method "${B}" has type "${typeof H}" in the component definition. Did you reference the function correctly?`
          );
    }
  if (s) {
    process.env.NODE_ENV !== "production" &&
      !I(s) &&
      O(
        "The data option must be a function. Plain object usage is no longer supported."
      );
    const B = s.call(o, o);
    if (
      (process.env.NODE_ENV !== "production" &&
        An(B) &&
        O(
          "data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."
        ),
      !G(B))
    )
      process.env.NODE_ENV !== "production" &&
        O("data() should return an object.");
    else if (((e.data = io(B)), process.env.NODE_ENV !== "production"))
      for (const H in B)
        nt("Data", H),
          Gn(H[0]) ||
            Object.defineProperty(n, H, {
              configurable: !0,
              enumerable: !0,
              get: () => B[H],
              set: ie,
            });
  }
  if (((Nn = !0), i))
    for (const B in i) {
      const H = i[B],
        Ae = I(H) ? H.bind(o, o) : I(H.get) ? H.get.bind(o, o) : ie;
      process.env.NODE_ENV !== "production" &&
        Ae === ie &&
        O(`Computed property "${B}" has no getter.`);
      const en =
          !I(H) && I(H.set)
            ? H.set.bind(o)
            : process.env.NODE_ENV !== "production"
            ? () => {
                O(
                  `Write operation failed: computed property "${B}" is readonly.`
                );
              }
            : ie,
        Mt = jo({
          get: Ae,
          set: en,
        });
      Object.defineProperty(n, B, {
        enumerable: !0,
        configurable: !0,
        get: () => Mt.value,
        set: (wt) => (Mt.value = wt),
      }),
        process.env.NODE_ENV !== "production" && nt("Computed", B);
    }
  if (l) for (const B in l) Ci(l[B], n, o, B);
  if (a) {
    const B = I(a) ? a.call(o) : a;
    Reflect.ownKeys(B).forEach((H) => {
      zl(H, B[H]);
    });
  }
  d && ps(d, e, "c");
  function _e(B, H) {
    $(H) ? H.forEach((Ae) => B(Ae.bind(o))) : H && B(H.bind(o));
  }
  if (
    (_e(Vl, u),
    _e(Yo, h),
    _e(Dl, m),
    _e(Sl, N),
    _e(wl, C),
    _e(Ol, Q),
    _e(Pl, ce),
    _e(Al, re),
    _e($l, De),
    _e(Cl, L),
    _e(Di, te),
    _e(Tl, me),
    $(We))
  )
    if (We.length) {
      const B = e.exposed || (e.exposed = {});
      We.forEach((H) => {
        Object.defineProperty(B, H, {
          get: () => o[H],
          set: (Ae) => (o[H] = Ae),
        });
      });
    } else e.exposed || (e.exposed = {});
  D && e.render === ie && (e.render = D),
    ot != null && (e.inheritAttrs = ot),
    Se && (e.components = Se),
    uo && (e.directives = uo),
    me && xi(e);
}
function Ul(e, t, o = ie) {
  $(e) && (e = wn(e));
  for (const n in e) {
    const s = e[n];
    let i;
    G(s)
      ? "default" in s
        ? (i = bo(s.from || n, s.default, !0))
        : (i = bo(s.from || n))
      : (i = bo(s)),
      oe(i)
        ? Object.defineProperty(t, n, {
            enumerable: !0,
            configurable: !0,
            get: () => i.value,
            set: (r) => (i.value = r),
          })
        : (t[n] = i),
      process.env.NODE_ENV !== "production" && o("Inject", n);
  }
}
function ps(e, t, o) {
  Ke($(e) ? e.map((n) => n.bind(t.proxy)) : e.bind(t.proxy), t, o);
}
function Ci(e, t, o, n) {
  let s = n.includes(".") ? Bi(o, n) : () => o[n];
  if (q(e)) {
    const i = t[e];
    I(i)
      ? dn(s, i)
      : process.env.NODE_ENV !== "production" &&
        O(`Invalid watch handler specified by key "${e}"`, i);
  } else if (I(e)) dn(s, e.bind(o));
  else if (G(e))
    if ($(e)) e.forEach((i) => Ci(i, t, o, n));
    else {
      const i = I(e.handler) ? e.handler.bind(o) : t[e.handler];
      I(i)
        ? dn(s, i, e)
        : process.env.NODE_ENV !== "production" &&
          O(`Invalid watch handler specified by key "${e.handler}"`, i);
    }
  else
    process.env.NODE_ENV !== "production" &&
      O(`Invalid watch option: "${n}"`, e);
}
function Ti(e) {
  const t = e.type,
    { mixins: o, extends: n } = t,
    {
      mixins: s,
      optionsCache: i,
      config: { optionMergeStrategies: r },
    } = e.appContext,
    l = i.get(t);
  let a;
  return (
    l
      ? (a = l)
      : !s.length && !o && !n
      ? (a = t)
      : ((a = {}), s.length && s.forEach((p) => ko(a, p, r, !0)), ko(a, t, r)),
    G(t) && i.set(t, a),
    a
  );
}
function ko(e, t, o, n = !1) {
  const { mixins: s, extends: i } = t;
  i && ko(e, i, o, !0), s && s.forEach((r) => ko(e, r, o, !0));
  for (const r in t)
    if (n && r === "expose")
      process.env.NODE_ENV !== "production" &&
        O(
          '"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.'
        );
    else {
      const l = Ll[r] || (o && o[r]);
      e[r] = l ? l(e[r], t[r]) : t[r];
    }
  return e;
}
const Ll = {
  data: hs,
  props: gs,
  emits: gs,
  // objects
  methods: Kt,
  computed: Kt,
  // lifecycle
  beforeCreate: de,
  created: de,
  beforeMount: de,
  mounted: de,
  beforeUpdate: de,
  updated: de,
  beforeDestroy: de,
  beforeUnmount: de,
  destroyed: de,
  unmounted: de,
  activated: de,
  deactivated: de,
  errorCaptured: de,
  serverPrefetch: de,
  // assets
  components: Kt,
  directives: Kt,
  // watch
  watch: Bl,
  // provide / inject
  provide: hs,
  inject: Hl,
};
function hs(e, t) {
  return t
    ? e
      ? function () {
          return ee(
            I(e) ? e.call(this, this) : e,
            I(t) ? t.call(this, this) : t
          );
        }
      : t
    : e;
}
function Hl(e, t) {
  return Kt(wn(e), wn(t));
}
function wn(e) {
  if ($(e)) {
    const t = {};
    for (let o = 0; o < e.length; o++) t[e[o]] = e[o];
    return t;
  }
  return e;
}
function de(e, t) {
  return e ? [...new Set([].concat(e, t))] : t;
}
function Kt(e, t) {
  return e ? ee(/* @__PURE__ */ Object.create(null), e, t) : t;
}
function gs(e, t) {
  return e
    ? $(e) && $(t)
      ? [.../* @__PURE__ */ new Set([...e, ...t])]
      : ee(/* @__PURE__ */ Object.create(null), ds(e), ds(t ?? {}))
    : t;
}
function Bl(e, t) {
  if (!e) return t;
  if (!t) return e;
  const o = ee(/* @__PURE__ */ Object.create(null), e);
  for (const n in t) o[n] = de(e[n], t[n]);
  return o;
}
function $i() {
  return {
    app: null,
    config: {
      isNativeTag: ir,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {},
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap(),
  };
}
let Kl = 0;
function Wl(e, t) {
  return function (n, s = null) {
    I(n) || (n = ee({}, n)),
      s != null &&
        !G(s) &&
        (process.env.NODE_ENV !== "production" &&
          O("root props passed to app.mount() must be an object."),
        (s = null));
    const i = $i(),
      r = /* @__PURE__ */ new WeakSet(),
      l = [];
    let a = !1;
    const p = (i.app = {
      _uid: Kl++,
      _component: n,
      _props: s,
      _container: null,
      _context: i,
      _instance: null,
      version: Ds,
      get config() {
        return i.config;
      },
      set config(d) {
        process.env.NODE_ENV !== "production" &&
          O(
            "app.config cannot be replaced. Modify individual options instead."
          );
      },
      use(d, ...u) {
        return (
          r.has(d)
            ? process.env.NODE_ENV !== "production" &&
              O("Plugin has already been applied to target app.")
            : d && I(d.install)
            ? (r.add(d), d.install(p, ...u))
            : I(d)
            ? (r.add(d), d(p, ...u))
            : process.env.NODE_ENV !== "production" &&
              O(
                'A plugin must either be a function or an object with an "install" function.'
              ),
          p
        );
      },
      mixin(d) {
        return (
          i.mixins.includes(d)
            ? process.env.NODE_ENV !== "production" &&
              O(
                "Mixin has already been applied to target app" +
                  (d.name ? `: ${d.name}` : "")
              )
            : i.mixins.push(d),
          p
        );
      },
      component(d, u) {
        return (
          process.env.NODE_ENV !== "production" && Sn(d, i.config),
          u
            ? (process.env.NODE_ENV !== "production" &&
                i.components[d] &&
                O(
                  `Component "${d}" has already been registered in target app.`
                ),
              (i.components[d] = u),
              p)
            : i.components[d]
        );
      },
      directive(d, u) {
        return (
          process.env.NODE_ENV !== "production" && Oi(d),
          u
            ? (process.env.NODE_ENV !== "production" &&
                i.directives[d] &&
                O(
                  `Directive "${d}" has already been registered in target app.`
                ),
              (i.directives[d] = u),
              p)
            : i.directives[d]
        );
      },
      mount(d, u, h) {
        if (a)
          process.env.NODE_ENV !== "production" &&
            O(
              "App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`"
            );
        else {
          process.env.NODE_ENV !== "production" &&
            d.__vue_app__ &&
            O(
              "There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first."
            );
          const m = p._ceVNode || Le(n, s);
          return (
            (m.appContext = i),
            h === !0 ? (h = "svg") : h === !1 && (h = void 0),
            process.env.NODE_ENV !== "production" &&
              (i.reload = () => {
                e(dt(m), d, h);
              }),
            e(m, d, h),
            (a = !0),
            (p._container = d),
            (d.__vue_app__ = p),
            process.env.NODE_ENV !== "production" &&
              ((p._instance = m.component), ul(p, Ds)),
            Zo(m.component)
          );
        }
      },
      onUnmount(d) {
        process.env.NODE_ENV !== "production" &&
          typeof d != "function" &&
          O(
            `Expected function as first argument to app.onUnmount(), but got ${typeof d}`
          ),
          l.push(d);
      },
      unmount() {
        a
          ? (Ke(l, p._instance, 16),
            e(null, p._container),
            process.env.NODE_ENV !== "production" &&
              ((p._instance = null), fl(p)),
            delete p._container.__vue_app__)
          : process.env.NODE_ENV !== "production" &&
            O("Cannot unmount an app that is not mounted.");
      },
      provide(d, u) {
        return (
          process.env.NODE_ENV !== "production" &&
            d in i.provides &&
            O(
              `App already provides property with key "${String(
                d
              )}". It will be overwritten with the new value.`
            ),
          (i.provides[d] = u),
          p
        );
      },
      runWithContext(d) {
        const u = $t;
        $t = p;
        try {
          return d();
        } finally {
          $t = u;
        }
      },
    });
    return p;
  };
}
let $t = null;
function zl(e, t) {
  if (!le)
    process.env.NODE_ENV !== "production" &&
      O("provide() can only be used inside setup().");
  else {
    let o = le.provides;
    const n = le.parent && le.parent.provides;
    n === o && (o = le.provides = Object.create(n)), (o[e] = t);
  }
}
function bo(e, t, o = !1) {
  const n = le || he;
  if (n || $t) {
    const s = $t
      ? $t._context.provides
      : n
      ? n.parent == null
        ? n.vnode.appContext && n.vnode.appContext.provides
        : n.parent.provides
      : void 0;
    if (s && e in s) return s[e];
    if (arguments.length > 1) return o && I(t) ? t.call(n && n.proxy) : t;
    process.env.NODE_ENV !== "production" &&
      O(`injection "${String(e)}" not found.`);
  } else
    process.env.NODE_ENV !== "production" &&
      O("inject() can only be used inside setup() or functional components.");
}
const Ai = {},
  Pi = () => Object.create(Ai),
  ki = (e) => Object.getPrototypeOf(e) === Ai;
function Jl(e, t, o, n = !1) {
  const s = {},
    i = Pi();
  (e.propsDefaults = /* @__PURE__ */ Object.create(null)), Ri(e, t, s, i);
  for (const r in e.propsOptions[0]) r in s || (s[r] = void 0);
  process.env.NODE_ENV !== "production" && Ii(t || {}, s, e),
    o
      ? (e.props = n ? s : Kr(s))
      : e.type.props
      ? (e.props = s)
      : (e.props = i),
    (e.attrs = i);
}
function Gl(e) {
  for (; e; ) {
    if (e.type.__hmrId) return !0;
    e = e.parent;
  }
}
function Yl(e, t, o, n) {
  const {
      props: s,
      attrs: i,
      vnode: { patchFlag: r },
    } = e,
    l = U(s),
    [a] = e.propsOptions;
  let p = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !(process.env.NODE_ENV !== "production" && Gl(e)) &&
    (n || r > 0) &&
    !(r & 16)
  ) {
    if (r & 8) {
      const d = e.vnode.dynamicProps;
      for (let u = 0; u < d.length; u++) {
        let h = d[u];
        if (Qo(e.emitsOptions, h)) continue;
        const m = t[h];
        if (a)
          if (W(i, h)) m !== i[h] && ((i[h] = m), (p = !0));
          else {
            const N = be(h);
            s[N] = On(a, l, N, m, e, !1);
          }
        else m !== i[h] && ((i[h] = m), (p = !0));
      }
    }
  } else {
    Ri(e, t, s, i) && (p = !0);
    let d;
    for (const u in l)
      (!t || // for camelCase
        (!W(t, u) && // it's possible the original props was passed in as kebab-case
          // and converted to camelCase (#955)
          ((d = we(u)) === u || !W(t, d)))) &&
        (a
          ? o && // for camelCase
            (o[u] !== void 0 || // for kebab-case
              o[d] !== void 0) &&
            (s[u] = On(a, l, u, void 0, e, !0))
          : delete s[u]);
    if (i !== l) for (const u in i) (!t || !W(t, u)) && (delete i[u], (p = !0));
  }
  p && je(e.attrs, "set", ""),
    process.env.NODE_ENV !== "production" && Ii(t || {}, s, e);
}
function Ri(e, t, o, n) {
  const [s, i] = e.propsOptions;
  let r = !1,
    l;
  if (t)
    for (let a in t) {
      if (Wt(a)) continue;
      const p = t[a];
      let d;
      s && W(s, (d = be(a)))
        ? !i || !i.includes(d)
          ? (o[d] = p)
          : ((l || (l = {}))[d] = p)
        : Qo(e.emitsOptions, a) ||
          ((!(a in n) || p !== n[a]) && ((n[a] = p), (r = !0)));
    }
  if (i) {
    const a = U(o),
      p = l || J;
    for (let d = 0; d < i.length; d++) {
      const u = i[d];
      o[u] = On(s, a, u, p[u], e, !W(p, u));
    }
  }
  return r;
}
function On(e, t, o, n, s, i) {
  const r = e[o];
  if (r != null) {
    const l = W(r, "default");
    if (l && n === void 0) {
      const a = r.default;
      if (r.type !== Function && !r.skipFactory && I(a)) {
        const { propsDefaults: p } = s;
        if (o in p) n = p[o];
        else {
          const d = ao(s);
          (n = p[o] = a.call(null, t)), d();
        }
      } else n = a;
      s.ce && s.ce._setProp(o, n);
    }
    r[0] &&
    /* shouldCast */
      (i && !l
        ? (n = !1)
        : r[1] &&
          /* shouldCastTrue */
          (n === "" || n === we(o)) &&
          (n = !0));
  }
  return n;
}
const Ql = /* @__PURE__ */ new WeakMap();
function Mi(e, t, o = !1) {
  const n = o ? Ql : t.propsCache,
    s = n.get(e);
  if (s) return s;
  const i = e.props,
    r = {},
    l = [];
  let a = !1;
  if (!I(e)) {
    const d = (u) => {
      a = !0;
      const [h, m] = Mi(u, t, !0);
      ee(r, h), m && l.push(...m);
    };
    !o && t.mixins.length && t.mixins.forEach(d),
      e.extends && d(e.extends),
      e.mixins && e.mixins.forEach(d);
  }
  if (!i && !a) return G(e) && n.set(e, Ct), Ct;
  if ($(i))
    for (let d = 0; d < i.length; d++) {
      process.env.NODE_ENV !== "production" &&
        !q(i[d]) &&
        O("props must be strings when using array syntax.", i[d]);
      const u = be(i[d]);
      ms(u) && (r[u] = J);
    }
  else if (i) {
    process.env.NODE_ENV !== "production" &&
      !G(i) &&
      O("invalid props options", i);
    for (const d in i) {
      const u = be(d);
      if (ms(u)) {
        const h = i[d],
          m = (r[u] = $(h) || I(h) ? { type: h } : ee({}, h)),
          N = m.type;
        let C = !1,
          Q = !0;
        if ($(N))
          for (let T = 0; T < N.length; ++T) {
            const L = N[T],
              A = I(L) && L.name;
            if (A === "Boolean") {
              C = !0;
              break;
            } else A === "String" && (Q = !1);
          }
        else C = I(N) && N.name === "Boolean";
        (m[0] =
        /* shouldCast */
          C),
          (m[1] =
          /* shouldCastTrue */
            Q),
          (C || W(m, "default")) && l.push(u);
      }
    }
  }
  const p = [r, l];
  return G(e) && n.set(e, p), p;
}
function ms(e) {
  return e[0] !== "$" && !Wt(e)
    ? !0
    : (process.env.NODE_ENV !== "production" &&
        O(`Invalid prop name: "${e}" is a reserved property.`),
      !1);
}
function Xl(e) {
  return e === null
    ? "null"
    : typeof e == "function"
    ? e.name || ""
    : (typeof e == "object" && e.constructor && e.constructor.name) || "";
}
function Ii(e, t, o) {
  const n = U(t),
    s = o.propsOptions[0],
    i = Object.keys(e).map((r) => be(r));
  for (const r in s) {
    let l = s[r];
    l != null &&
      Zl(
        r,
        n[r],
        l,
        process.env.NODE_ENV !== "production" ? Fe(n) : n,
        !i.includes(r)
      );
  }
}
function Zl(e, t, o, n, s) {
  const { type: i, required: r, validator: l, skipCheck: a } = o;
  if (r && s) {
    O('Missing required prop: "' + e + '"');
    return;
  }
  if (!(t == null && !r)) {
    if (i != null && i !== !0 && !a) {
      let p = !1;
      const d = $(i) ? i : [i],
        u = [];
      for (let h = 0; h < d.length && !p; h++) {
        const { valid: m, expectedType: N } = ec(t, d[h]);
        u.push(N || ""), (p = m);
      }
      if (!p) {
        O(tc(e, t, u));
        return;
      }
    }
    l &&
      !l(t, n) &&
      O('Invalid prop: custom validator check failed for prop "' + e + '".');
  }
}
const ql = /* @__PURE__ */ Ze("String,Number,Boolean,Function,Symbol,BigInt");
function ec(e, t) {
  let o;
  const n = Xl(t);
  if (n === "null") o = e === null;
  else if (ql(n)) {
    const s = typeof e;
    (o = s === n.toLowerCase()), !o && s === "object" && (o = e instanceof t);
  } else
    n === "Object"
      ? (o = G(e))
      : n === "Array"
      ? (o = $(e))
      : (o = e instanceof t);
  return {
    valid: o,
    expectedType: n,
  };
}
function tc(e, t, o) {
  if (o.length === 0)
    return `Prop type [] for prop "${e}" won't match anything. Did you mean to use type Array instead?`;
  let n = `Invalid prop: type check failed for prop "${e}". Expected ${o
    .map(Bo)
    .join(" | ")}`;
  const s = o[0],
    i = Pn(t),
    r = _s(t, s),
    l = _s(t, i);
  return (
    o.length === 1 && vs(s) && !oc(s, i) && (n += ` with value ${r}`),
    (n += `, got ${i} `),
    vs(i) && (n += `with value ${l}.`),
    n
  );
}
function _s(e, t) {
  return t === "String" ? `"${e}"` : t === "Number" ? `${Number(e)}` : `${e}`;
}
function vs(e) {
  return ["string", "number", "boolean"].some((o) => e.toLowerCase() === o);
}
function oc(...e) {
  return e.some((t) => t.toLowerCase() === "boolean");
}
const ji = (e) => e[0] === "_" || e === "$stable",
  Yn = (e) => ($(e) ? e.map(Ce) : [Ce(e)]),
  nc = (e, t, o) => {
    if (t._n) return t;
    const n = vl(
      (...s) => (
        process.env.NODE_ENV !== "production" &&
          le &&
          (!o || o.root === le.root) &&
          O(
            `Slot "${e}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
          ),
        Yn(t(...s))
      ),
      o
    );
    return (n._c = !1), n;
  },
  Fi = (e, t, o) => {
    const n = e._ctx;
    for (const s in e) {
      if (ji(s)) continue;
      const i = e[s];
      if (I(i)) t[s] = nc(s, i, n);
      else if (i != null) {
        process.env.NODE_ENV !== "production" &&
          O(
            `Non-function value encountered for slot "${s}". Prefer function slots for better performance.`
          );
        const r = Yn(i);
        t[s] = () => r;
      }
    }
  },
  Ui = (e, t) => {
    process.env.NODE_ENV !== "production" &&
      !Jn(e.vnode) &&
      O(
        "Non-function value encountered for default slot. Prefer function slots for better performance."
      );
    const o = Yn(t);
    e.slots.default = () => o;
  },
  xn = (e, t, o) => {
    for (const n in t) (o || n !== "_") && (e[n] = t[n]);
  },
  sc = (e, t, o) => {
    const n = (e.slots = Pi());
    if (e.vnode.shapeFlag & 32) {
      const s = t._;
      s ? (xn(n, t, o), o && xo(n, "_", s, !0)) : Fi(t, n);
    } else t && Ui(e, t);
  },
  ic = (e, t, o) => {
    const { vnode: n, slots: s } = e;
    let i = !0,
      r = J;
    if (n.shapeFlag & 32) {
      const l = t._;
      l
        ? process.env.NODE_ENV !== "production" && Ue
          ? (xn(s, t, o), je(e, "set", "$slots"))
          : o && l === 1
          ? (i = !1)
          : xn(s, t, o)
        : ((i = !t.$stable), Fi(t, s)),
        (r = t);
    } else t && (Ui(e, t), (r = { default: 1 }));
    if (i) for (const l in s) !ji(l) && r[l] == null && delete s[l];
  };
let Lt, ct;
function xt(e, t) {
  e.appContext.config.performance && Ro() && ct.mark(`vue-${t}-${e.uid}`),
    process.env.NODE_ENV !== "production" &&
      gl(e, t, Ro() ? ct.now() : Date.now());
}
function Vt(e, t) {
  if (e.appContext.config.performance && Ro()) {
    const o = `vue-${t}-${e.uid}`,
      n = o + ":end";
    ct.mark(n),
      ct.measure(`<${qo(e, e.type)}> ${t}`, o, n),
      ct.clearMarks(o),
      ct.clearMarks(n);
  }
  process.env.NODE_ENV !== "production" &&
    ml(e, t, Ro() ? ct.now() : Date.now());
}
function Ro() {
  return (
    Lt !== void 0 ||
      (typeof window < "u" && window.performance
        ? ((Lt = !0), (ct = window.performance))
        : (Lt = !1)),
    Lt
  );
}
function rc() {
  const e = [];
  if (process.env.NODE_ENV !== "production" && e.length) {
    const t = e.length > 1;
    console.warn(
      `Feature flag${t ? "s" : ""} ${e.join(", ")} ${
        t ? "are" : "is"
      } not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
    );
  }
}
const Ee = yc;
function lc(e) {
  return cc(e);
}
function cc(e, t) {
  rc();
  const o = so();
  (o.__VUE__ = !0),
    process.env.NODE_ENV !== "production" &&
      Kn(o.__VUE_DEVTOOLS_GLOBAL_HOOK__, o);
  const {
      insert: n,
      remove: s,
      patchProp: i,
      createElement: r,
      createText: l,
      createComment: a,
      setText: p,
      setElementText: d,
      parentNode: u,
      nextSibling: h,
      setScopeId: m = ie,
      insertStaticContent: N,
    } = e,
    C = (
      c,
      f,
      g,
      b = null,
      _ = null,
      v = null,
      x = void 0,
      w = null,
      E = process.env.NODE_ENV !== "production" && Ue ? !1 : !!f.dynamicChildren
    ) => {
      if (c === f) return;
      c && !Ht(c, f) && ((b = fo(c)), st(c, _, v, !0), (c = null)),
        f.patchFlag === -2 && ((E = !1), (f.dynamicChildren = null));
      const { type: y, ref: M, shapeFlag: V } = f;
      switch (y) {
        case co:
          Q(c, f, g, b);
          break;
        case xe:
          T(c, f, g, b);
          break;
        case Eo:
          c == null
            ? L(f, g, b, x)
            : process.env.NODE_ENV !== "production" && A(c, f, g, x);
          break;
        case Z:
          uo(c, f, g, b, _, v, x, w, E);
          break;
        default:
          V & 1
            ? re(c, f, g, b, _, v, x, w, E)
            : V & 6
            ? es(c, f, g, b, _, v, x, w, E)
            : V & 64 || V & 128
            ? y.process(c, f, g, b, _, v, x, w, E, jt)
            : process.env.NODE_ENV !== "production" &&
              O("Invalid VNode type:", y, `(${typeof y})`);
      }
      M != null && _ && Po(M, c && c.ref, v, f || c, !f);
    },
    Q = (c, f, g, b) => {
      if (c == null) n((f.el = l(f.children)), g, b);
      else {
        const _ = (f.el = c.el);
        f.children !== c.children && p(_, f.children);
      }
    },
    T = (c, f, g, b) => {
      c == null ? n((f.el = a(f.children || "")), g, b) : (f.el = c.el);
    },
    L = (c, f, g, b) => {
      [c.el, c.anchor] = N(c.children, f, g, b, c.el, c.anchor);
    },
    A = (c, f, g, b) => {
      if (f.children !== c.children) {
        const _ = h(c.anchor);
        D(c), ([f.el, f.anchor] = N(f.children, g, _, b));
      } else (f.el = c.el), (f.anchor = c.anchor);
    },
    te = ({ el: c, anchor: f }, g, b) => {
      let _;
      for (; c && c !== f; ) (_ = h(c)), n(c, g, b), (c = _);
      n(f, g, b);
    },
    D = ({ el: c, anchor: f }) => {
      let g;
      for (; c && c !== f; ) (g = h(c)), s(c), (c = g);
      s(f);
    },
    re = (c, f, g, b, _, v, x, w, E) => {
      f.type === "svg" ? (x = "svg") : f.type === "math" && (x = "mathml"),
        c == null ? De(f, g, b, _, v, x, w, E) : We(c, f, _, v, x, w, E);
    },
    De = (c, f, g, b, _, v, x, w) => {
      let E, y;
      const { props: M, shapeFlag: V, transition: P, dirs: j } = c;
      if (
        ((E = c.el = r(c.type, v, M && M.is, M)),
        V & 8
          ? d(E, c.children)
          : V & 16 && me(c.children, E, null, b, _, fn(c, v), x, w),
        j && pt(c, null, b, "created"),
        ce(E, c, c.scopeId, x, b),
        M)
      ) {
        for (const X in M) X !== "value" && !Wt(X) && i(E, X, null, M[X], v, b);
        "value" in M && i(E, "value", null, M.value, v),
          (y = M.onVnodeBeforeMount) && Me(y, b, c);
      }
      process.env.NODE_ENV !== "production" &&
        (xo(E, "__vnode", c, !0), xo(E, "__vueParentComponent", b, !0)),
        j && pt(c, null, b, "beforeMount");
      const K = ac(_, P);
      K && P.beforeEnter(E),
        n(E, f, g),
        ((y = M && M.onVnodeMounted) || K || j) &&
          Ee(() => {
            y && Me(y, b, c), K && P.enter(E), j && pt(c, null, b, "mounted");
          }, _);
    },
    ce = (c, f, g, b, _) => {
      if ((g && m(c, g), b)) for (let v = 0; v < b.length; v++) m(c, b[v]);
      if (_) {
        let v = _.subTree;
        if (
          (process.env.NODE_ENV !== "production" &&
            v.patchFlag > 0 &&
            v.patchFlag & 2048 &&
            (v = Qn(v.children) || v),
          f === v || (zi(v.type) && (v.ssContent === f || v.ssFallback === f)))
        ) {
          const x = _.vnode;
          ce(c, x, x.scopeId, x.slotScopeIds, _.parent);
        }
      }
    },
    me = (c, f, g, b, _, v, x, w, E = 0) => {
      for (let y = E; y < c.length; y++) {
        const M = (c[y] = w ? lt(c[y]) : Ce(c[y]));
        C(null, M, f, g, b, _, v, x, w);
      }
    },
    We = (c, f, g, b, _, v, x) => {
      const w = (f.el = c.el);
      process.env.NODE_ENV !== "production" && (w.__vnode = f);
      let { patchFlag: E, dynamicChildren: y, dirs: M } = f;
      E |= c.patchFlag & 16;
      const V = c.props || J,
        P = f.props || J;
      let j;
      if (
        (g && ht(g, !1),
        (j = P.onVnodeBeforeUpdate) && Me(j, g, f, c),
        M && pt(f, c, g, "beforeUpdate"),
        g && ht(g, !0),
        process.env.NODE_ENV !== "production" &&
          Ue &&
          ((E = 0), (x = !1), (y = null)),
        ((V.innerHTML && P.innerHTML == null) ||
          (V.textContent && P.textContent == null)) &&
          d(w, ""),
        y
          ? (ot(c.dynamicChildren, y, w, g, b, fn(f, _), v),
            process.env.NODE_ENV !== "production" && yo(c, f))
          : x || Ae(c, f, w, null, g, b, fn(f, _), v, !1),
        E > 0)
      ) {
        if (E & 16) Se(w, V, P, g, _);
        else if (
          (E & 2 && V.class !== P.class && i(w, "class", null, P.class, _),
          E & 4 && i(w, "style", V.style, P.style, _),
          E & 8)
        ) {
          const K = f.dynamicProps;
          for (let X = 0; X < K.length; X++) {
            const Y = K[X],
              ye = V[Y],
              ve = P[Y];
            (ve !== ye || Y === "value") && i(w, Y, ye, ve, _, g);
          }
        }
        E & 1 && c.children !== f.children && d(w, f.children);
      } else !x && y == null && Se(w, V, P, g, _);
      ((j = P.onVnodeUpdated) || M) &&
        Ee(() => {
          j && Me(j, g, f, c), M && pt(f, c, g, "updated");
        }, b);
    },
    ot = (c, f, g, b, _, v, x) => {
      for (let w = 0; w < f.length; w++) {
        const E = c[w],
          y = f[w],
          M =
            // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            E.el && // - In the case of a Fragment, we need to provide the actual parent
            // of the Fragment itself so it can move its children.
            (E.type === Z || // - In the case of different nodes, there is going to be a replacement
              // which also requires the correct parent container
              !Ht(E, y) || // - In the case of a component, it could contain anything.
              E.shapeFlag & 70)
              ? u(E.el)
              : // In other cases, the parent container is not actually used so we
                // just pass the block element here to avoid a DOM parentNode call.
                g;
        C(E, y, M, null, b, _, v, x, !0);
      }
    },
    Se = (c, f, g, b, _) => {
      if (f !== g) {
        if (f !== J)
          for (const v in f) !Wt(v) && !(v in g) && i(c, v, f[v], null, _, b);
        for (const v in g) {
          if (Wt(v)) continue;
          const x = g[v],
            w = f[v];
          x !== w && v !== "value" && i(c, v, w, x, _, b);
        }
        "value" in g && i(c, "value", f.value, g.value, _);
      }
    },
    uo = (c, f, g, b, _, v, x, w, E) => {
      const y = (f.el = c ? c.el : l("")),
        M = (f.anchor = c ? c.anchor : l(""));
      let { patchFlag: V, dynamicChildren: P, slotScopeIds: j } = f;
      process.env.NODE_ENV !== "production" && // #5523 dev root fragment may inherit directives
        (Ue || V & 2048) &&
        ((V = 0), (E = !1), (P = null)),
        j && (w = w ? w.concat(j) : j),
        c == null
          ? (n(y, g, b),
            n(M, g, b),
            me(
              // #10007
              // such fragment like `<></>` will be compiled into
              // a fragment which doesn't have a children.
              // In this case fallback to an empty array
              f.children || [],
              g,
              M,
              _,
              v,
              x,
              w,
              E
            ))
          : V > 0 &&
            V & 64 &&
            P && // #2715 the previous fragment could've been a BAILed one as a result
            // of renderSlot() with no valid children
            c.dynamicChildren
          ? (ot(c.dynamicChildren, P, g, _, v, x, w),
            process.env.NODE_ENV !== "production"
              ? yo(c, f)
              : // #2080 if the stable fragment has a key, it's a <template v-for> that may
                //  get moved around. Make sure all root level vnodes inherit el.
                // #2134 or if it's a component root, it may also get moved around
                // as the component is being moved.
                (f.key != null || (_ && f === _.subTree)) &&
                yo(
                  c,
                  f,
                  !0
                  /* shallow */
                ))
          : Ae(c, f, g, M, _, v, x, w, E);
    },
    es = (c, f, g, b, _, v, x, w, E) => {
      (f.slotScopeIds = w),
        c == null
          ? f.shapeFlag & 512
            ? _.ctx.activate(f, g, b, x, E)
            : nt(f, g, b, _, v, x, E)
          : _e(c, f, E);
    },
    nt = (c, f, g, b, _, v, x) => {
      const w = (c.component = Cc(c, b, _));
      if (
        (process.env.NODE_ENV !== "production" && w.type.__hmrId && rl(w),
        process.env.NODE_ENV !== "production" && (mo(c), xt(w, "mount")),
        Jn(c) && (w.ctx.renderer = jt),
        process.env.NODE_ENV !== "production" && xt(w, "init"),
        Ac(w, !1, x),
        process.env.NODE_ENV !== "production" && Vt(w, "init"),
        w.asyncDep)
      ) {
        if (
          (process.env.NODE_ENV !== "production" && Ue && (c.el = null),
          _ && _.registerDep(w, B, x),
          !c.el)
        ) {
          const E = (w.subTree = Le(xe));
          T(null, E, f, g);
        }
      } else B(w, c, f, g, _, v, x);
      process.env.NODE_ENV !== "production" && (_o(), Vt(w, "mount"));
    },
    _e = (c, f, g) => {
      const b = (f.component = c.component);
      if (vc(c, f, g))
        if (b.asyncDep && !b.asyncResolved) {
          process.env.NODE_ENV !== "production" && mo(f),
            H(b, f, g),
            process.env.NODE_ENV !== "production" && _o();
          return;
        } else (b.next = f), b.update();
      else (f.el = c.el), (b.vnode = f);
    },
    B = (c, f, g, b, _, v, x) => {
      const w = () => {
        if (c.isMounted) {
          let { next: V, bu: P, u: j, parent: K, vnode: X } = c;
          {
            const ke = Li(c);
            if (ke) {
              V && ((V.el = X.el), H(c, V, x)),
                ke.asyncDep.then(() => {
                  c.isUnmounted || w();
                });
              return;
            }
          }
          let Y = V,
            ye;
          process.env.NODE_ENV !== "production" && mo(V || c.vnode),
            ht(c, !1),
            V ? ((V.el = X.el), H(c, V, x)) : (V = X),
            P && Dt(P),
            (ye = V.props && V.props.onVnodeBeforeUpdate) && Me(ye, K, V, X),
            ht(c, !0),
            process.env.NODE_ENV !== "production" && xt(c, "render");
          const ve = ys(c);
          process.env.NODE_ENV !== "production" && Vt(c, "render");
          const Pe = c.subTree;
          (c.subTree = ve),
            process.env.NODE_ENV !== "production" && xt(c, "patch"),
            C(
              Pe,
              ve,
              // parent may have changed if it's in a teleport
              u(Pe.el),
              // anchor may have changed if it's in a fragment
              fo(Pe),
              c,
              _,
              v
            ),
            process.env.NODE_ENV !== "production" && Vt(c, "patch"),
            (V.el = ve.el),
            Y === null && bc(c, ve.el),
            j && Ee(j, _),
            (ye = V.props && V.props.onVnodeUpdated) &&
              Ee(() => Me(ye, K, V, X), _),
            process.env.NODE_ENV !== "production" && Ei(c),
            process.env.NODE_ENV !== "production" && _o();
        } else {
          let V;
          const { el: P, props: j } = f,
            { bm: K, m: X, parent: Y, root: ye, type: ve } = c,
            Pe = Gt(f);
          ht(c, !1),
            K && Dt(K),
            !Pe && (V = j && j.onVnodeBeforeMount) && Me(V, Y, f),
            ht(c, !0);
          {
            ye.ce && ye.ce._injectChildStyle(ve),
              process.env.NODE_ENV !== "production" && xt(c, "render");
            const ke = (c.subTree = ys(c));
            process.env.NODE_ENV !== "production" && Vt(c, "render"),
              process.env.NODE_ENV !== "production" && xt(c, "patch"),
              C(null, ke, g, b, c, _, v),
              process.env.NODE_ENV !== "production" && Vt(c, "patch"),
              (f.el = ke.el);
          }
          if ((X && Ee(X, _), !Pe && (V = j && j.onVnodeMounted))) {
            const ke = f;
            Ee(() => Me(V, Y, ke), _);
          }
          (f.shapeFlag & 256 ||
            (Y && Gt(Y.vnode) && Y.vnode.shapeFlag & 256)) &&
            c.a &&
            Ee(c.a, _),
            (c.isMounted = !0),
            process.env.NODE_ENV !== "production" && dl(c),
            (f = g = b = null);
        }
      };
      c.scope.on();
      const E = (c.effect = new Qs(w));
      c.scope.off();
      const y = (c.update = E.run.bind(E)),
        M = (c.job = E.runIfDirty.bind(E));
      (M.i = c),
        (M.id = c.uid),
        (E.scheduler = () => Jo(M)),
        ht(c, !0),
        process.env.NODE_ENV !== "production" &&
          ((E.onTrack = c.rtc ? (V) => Dt(c.rtc, V) : void 0),
          (E.onTrigger = c.rtg ? (V) => Dt(c.rtg, V) : void 0)),
        y();
    },
    H = (c, f, g) => {
      f.component = c;
      const b = c.vnode.props;
      (c.vnode = f),
        (c.next = null),
        Yl(c, f.props, b, g),
        ic(c, f.children, g),
        qe(),
        us(c),
        et();
    },
    Ae = (c, f, g, b, _, v, x, w, E = !1) => {
      const y = c && c.children,
        M = c ? c.shapeFlag : 0,
        V = f.children,
        { patchFlag: P, shapeFlag: j } = f;
      if (P > 0) {
        if (P & 128) {
          Mt(y, V, g, b, _, v, x, w, E);
          return;
        } else if (P & 256) {
          en(y, V, g, b, _, v, x, w, E);
          return;
        }
      }
      j & 8
        ? (M & 16 && It(y, _, v), V !== y && d(g, V))
        : M & 16
        ? j & 16
          ? Mt(y, V, g, b, _, v, x, w, E)
          : It(y, _, v, !0)
        : (M & 8 && d(g, ""), j & 16 && me(V, g, b, _, v, x, w, E));
    },
    en = (c, f, g, b, _, v, x, w, E) => {
      (c = c || Ct), (f = f || Ct);
      const y = c.length,
        M = f.length,
        V = Math.min(y, M);
      let P;
      for (P = 0; P < V; P++) {
        const j = (f[P] = E ? lt(f[P]) : Ce(f[P]));
        C(c[P], j, g, null, _, v, x, w, E);
      }
      y > M ? It(c, _, v, !0, !1, V) : me(f, g, b, _, v, x, w, E, V);
    },
    Mt = (c, f, g, b, _, v, x, w, E) => {
      let y = 0;
      const M = f.length;
      let V = c.length - 1,
        P = M - 1;
      for (; y <= V && y <= P; ) {
        const j = c[y],
          K = (f[y] = E ? lt(f[y]) : Ce(f[y]));
        if (Ht(j, K)) C(j, K, g, null, _, v, x, w, E);
        else break;
        y++;
      }
      for (; y <= V && y <= P; ) {
        const j = c[V],
          K = (f[P] = E ? lt(f[P]) : Ce(f[P]));
        if (Ht(j, K)) C(j, K, g, null, _, v, x, w, E);
        else break;
        V--, P--;
      }
      if (y > V) {
        if (y <= P) {
          const j = P + 1,
            K = j < M ? f[j].el : b;
          for (; y <= P; )
            C(null, (f[y] = E ? lt(f[y]) : Ce(f[y])), g, K, _, v, x, w, E), y++;
        }
      } else if (y > P) for (; y <= V; ) st(c[y], _, v, !0), y++;
      else {
        const j = y,
          K = y,
          X = /* @__PURE__ */ new Map();
        for (y = K; y <= P; y++) {
          const fe = (f[y] = E ? lt(f[y]) : Ce(f[y]));
          fe.key != null &&
            (process.env.NODE_ENV !== "production" &&
              X.has(fe.key) &&
              O(
                "Duplicate keys found during update:",
                JSON.stringify(fe.key),
                "Make sure keys are unique."
              ),
            X.set(fe.key, y));
        }
        let Y,
          ye = 0;
        const ve = P - K + 1;
        let Pe = !1,
          ke = 0;
        const Ft = new Array(ve);
        for (y = 0; y < ve; y++) Ft[y] = 0;
        for (y = j; y <= V; y++) {
          const fe = c[y];
          if (ye >= ve) {
            st(fe, _, v, !0);
            continue;
          }
          let Re;
          if (fe.key != null) Re = X.get(fe.key);
          else
            for (Y = K; Y <= P; Y++)
              if (Ft[Y - K] === 0 && Ht(fe, f[Y])) {
                Re = Y;
                break;
              }
          Re === void 0
            ? st(fe, _, v, !0)
            : ((Ft[Re - K] = y + 1),
              Re >= ke ? (ke = Re) : (Pe = !0),
              C(fe, f[Re], g, null, _, v, x, w, E),
              ye++);
        }
        const os = Pe ? uc(Ft) : Ct;
        for (Y = os.length - 1, y = ve - 1; y >= 0; y--) {
          const fe = K + y,
            Re = f[fe],
            ns = fe + 1 < M ? f[fe + 1].el : b;
          Ft[y] === 0
            ? C(null, Re, g, ns, _, v, x, w, E)
            : Pe && (Y < 0 || y !== os[Y] ? wt(Re, g, ns, 2) : Y--);
        }
      }
    },
    wt = (c, f, g, b, _ = null) => {
      const { el: v, type: x, transition: w, children: E, shapeFlag: y } = c;
      if (y & 6) {
        wt(c.component.subTree, f, g, b);
        return;
      }
      if (y & 128) {
        c.suspense.move(f, g, b);
        return;
      }
      if (y & 64) {
        x.move(c, f, g, jt);
        return;
      }
      if (x === Z) {
        n(v, f, g);
        for (let V = 0; V < E.length; V++) wt(E[V], f, g, b);
        n(c.anchor, f, g);
        return;
      }
      if (x === Eo) {
        te(c, f, g);
        return;
      }
      if (b !== 2 && y & 1 && w)
        if (b === 0) w.beforeEnter(v), n(v, f, g), Ee(() => w.enter(v), _);
        else {
          const { leave: V, delayLeave: P, afterLeave: j } = w,
            K = () => n(v, f, g),
            X = () => {
              V(v, () => {
                K(), j && j();
              });
            };
          P ? P(v, K, X) : X();
        }
      else n(v, f, g);
    },
    st = (c, f, g, b = !1, _ = !1) => {
      const {
        type: v,
        props: x,
        ref: w,
        children: E,
        dynamicChildren: y,
        shapeFlag: M,
        patchFlag: V,
        dirs: P,
        cacheIndex: j,
      } = c;
      if (
        (V === -2 && (_ = !1),
        w != null && Po(w, null, g, c, !0),
        j != null && (f.renderCache[j] = void 0),
        M & 256)
      ) {
        f.ctx.deactivate(c);
        return;
      }
      const K = M & 1 && P,
        X = !Gt(c);
      let Y;
      if ((X && (Y = x && x.onVnodeBeforeUnmount) && Me(Y, f, c), M & 6))
        sr(c.component, g, b);
      else {
        if (M & 128) {
          c.suspense.unmount(g, b);
          return;
        }
        K && pt(c, null, f, "beforeUnmount"),
          M & 64
            ? c.type.remove(c, f, g, jt, b)
            : y && // #5154
              // when v-once is used inside a block, setBlockTracking(-1) marks the
              // parent block with hasOnce: true
              // so that it doesn't take the fast path during unmount - otherwise
              // components nested in v-once are never unmounted.
              !y.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
              (v !== Z || (V > 0 && V & 64))
            ? It(y, f, g, !1, !0)
            : ((v === Z && V & 384) || (!_ && M & 16)) && It(E, f, g),
          b && tn(c);
      }
      ((X && (Y = x && x.onVnodeUnmounted)) || K) &&
        Ee(() => {
          Y && Me(Y, f, c), K && pt(c, null, f, "unmounted");
        }, g);
    },
    tn = (c) => {
      const { type: f, el: g, anchor: b, transition: _ } = c;
      if (f === Z) {
        process.env.NODE_ENV !== "production" &&
        c.patchFlag > 0 &&
        c.patchFlag & 2048 &&
        _ &&
        !_.persisted
          ? c.children.forEach((x) => {
              x.type === xe ? s(x.el) : tn(x);
            })
          : nr(g, b);
        return;
      }
      if (f === Eo) {
        D(c);
        return;
      }
      const v = () => {
        s(g), _ && !_.persisted && _.afterLeave && _.afterLeave();
      };
      if (c.shapeFlag & 1 && _ && !_.persisted) {
        const { leave: x, delayLeave: w } = _,
          E = () => x(g, v);
        w ? w(c.el, v, E) : E();
      } else v();
    },
    nr = (c, f) => {
      let g;
      for (; c !== f; ) (g = h(c)), s(c), (c = g);
      s(f);
    },
    sr = (c, f, g) => {
      process.env.NODE_ENV !== "production" && c.type.__hmrId && ll(c);
      const { bum: b, scope: _, job: v, subTree: x, um: w, m: E, a: y } = c;
      bs(E),
        bs(y),
        b && Dt(b),
        _.stop(),
        v && ((v.flags |= 8), st(x, c, f, g)),
        w && Ee(w, f),
        Ee(() => {
          c.isUnmounted = !0;
        }, f),
        f &&
          f.pendingBranch &&
          !f.isUnmounted &&
          c.asyncDep &&
          !c.asyncResolved &&
          c.suspenseId === f.pendingId &&
          (f.deps--, f.deps === 0 && f.resolve()),
        process.env.NODE_ENV !== "production" && hl(c);
    },
    It = (c, f, g, b = !1, _ = !1, v = 0) => {
      for (let x = v; x < c.length; x++) st(c[x], f, g, b, _);
    },
    fo = (c) => {
      if (c.shapeFlag & 6) return fo(c.component.subTree);
      if (c.shapeFlag & 128) return c.suspense.next();
      const f = h(c.anchor || c.el),
        g = f && f[bl];
      return g ? h(g) : f;
    };
  let on = !1;
  const ts = (c, f, g) => {
      c == null
        ? f._vnode && st(f._vnode, null, null, !0)
        : C(f._vnode || null, c, f, null, null, null, g),
        (f._vnode = c),
        on || ((on = !0), us(), vi(), (on = !1));
    },
    jt = {
      p: C,
      um: st,
      m: wt,
      r: tn,
      mt: nt,
      mc: me,
      pc: Ae,
      pbc: ot,
      n: fo,
      o: e,
    };
  return {
    render: ts,
    hydrate: void 0,
    createApp: Wl(ts),
  };
}
function fn({ type: e, props: t }, o) {
  return (o === "svg" && e === "foreignObject") ||
    (o === "mathml" &&
      e === "annotation-xml" &&
      t &&
      t.encoding &&
      t.encoding.includes("html"))
    ? void 0
    : o;
}
function ht({ effect: e, job: t }, o) {
  o ? ((e.flags |= 32), (t.flags |= 4)) : ((e.flags &= -33), (t.flags &= -5));
}
function ac(e, t) {
  return (!e || (e && !e.pendingBranch)) && t && !t.persisted;
}
function yo(e, t, o = !1) {
  const n = e.children,
    s = t.children;
  if ($(n) && $(s))
    for (let i = 0; i < n.length; i++) {
      const r = n[i];
      let l = s[i];
      l.shapeFlag & 1 &&
        !l.dynamicChildren &&
        ((l.patchFlag <= 0 || l.patchFlag === 32) &&
          ((l = s[i] = lt(s[i])), (l.el = r.el)),
        !o && l.patchFlag !== -2 && yo(r, l)),
        l.type === co && (l.el = r.el),
        process.env.NODE_ENV !== "production" &&
          l.type === xe &&
          !l.el &&
          (l.el = r.el);
    }
}
function uc(e) {
  const t = e.slice(),
    o = [0];
  let n, s, i, r, l;
  const a = e.length;
  for (n = 0; n < a; n++) {
    const p = e[n];
    if (p !== 0) {
      if (((s = o[o.length - 1]), e[s] < p)) {
        (t[n] = s), o.push(n);
        continue;
      }
      for (i = 0, r = o.length - 1; i < r; )
        (l = (i + r) >> 1), e[o[l]] < p ? (i = l + 1) : (r = l);
      p < e[o[i]] && (i > 0 && (t[n] = o[i - 1]), (o[i] = n));
    }
  }
  for (i = o.length, r = o[i - 1]; i-- > 0; ) (o[i] = r), (r = t[r]);
  return o;
}
function Li(e) {
  const t = e.subTree.component;
  if (t) return t.asyncDep && !t.asyncResolved ? t : Li(t);
}
function bs(e) {
  if (e) for (let t = 0; t < e.length; t++) e[t].flags |= 8;
}
const fc = Symbol.for("v-scx"),
  dc = () => {
    {
      const e = bo(fc);
      return (
        e ||
          (process.env.NODE_ENV !== "production" &&
            O(
              "Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."
            )),
        e
      );
    }
  };
function dn(e, t, o) {
  return (
    process.env.NODE_ENV !== "production" &&
      !I(t) &&
      O(
        "`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."
      ),
    Hi(e, t, o)
  );
}
function Hi(e, t, o = J) {
  const { immediate: n, deep: s, flush: i, once: r } = o;
  process.env.NODE_ENV !== "production" &&
    !t &&
    (n !== void 0 &&
      O(
        'watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'
      ),
    s !== void 0 &&
      O(
        'watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'
      ),
    r !== void 0 &&
      O(
        'watch() "once" option is only respected when using the watch(source, callback, options?) signature.'
      ));
  const l = ee({}, o);
  process.env.NODE_ENV !== "production" && (l.onWarn = O);
  const a = (t && n) || (!t && i !== "post");
  let p;
  if (eo) {
    if (i === "sync") {
      const m = dc();
      p = m.__watcherHandles || (m.__watcherHandles = []);
    } else if (!a) {
      const m = () => {};
      return (m.stop = ie), (m.resume = ie), (m.pause = ie), m;
    }
  }
  const d = le;
  l.call = (m, N, C) => Ke(m, d, N, C);
  let u = !1;
  i === "post"
    ? (l.scheduler = (m) => {
        Ee(m, d && d.suspense);
      })
    : i !== "sync" &&
      ((u = !0),
      (l.scheduler = (m, N) => {
        N ? m() : Jo(m);
      })),
    (l.augmentJob = (m) => {
      t && (m.flags |= 4),
        u && ((m.flags |= 2), d && ((m.id = d.uid), (m.i = d)));
    });
  const h = Zr(e, t, l);
  return eo && (p ? p.push(h) : a && h()), h;
}
function pc(e, t, o) {
  const n = this.proxy,
    s = q(e) ? (e.includes(".") ? Bi(n, e) : () => n[e]) : e.bind(n, n);
  let i;
  I(t) ? (i = t) : ((i = t.handler), (o = t));
  const r = ao(this),
    l = Hi(s, i.bind(n), o);
  return r(), l;
}
function Bi(e, t) {
  const o = t.split(".");
  return () => {
    let n = e;
    for (let s = 0; s < o.length && n; s++) n = n[o[s]];
    return n;
  };
}
const hc = (e, t) =>
  t === "modelValue" || t === "model-value"
    ? e.modelModifiers
    : e[`${t}Modifiers`] || e[`${be(t)}Modifiers`] || e[`${we(t)}Modifiers`];
function gc(e, t, ...o) {
  if (e.isUnmounted) return;
  const n = e.vnode.props || J;
  if (process.env.NODE_ENV !== "production") {
    const {
      emitsOptions: d,
      propsOptions: [u],
    } = e;
    if (d)
      if (!(t in d))
        (!u || !(gt(be(t)) in u)) &&
          O(
            `Component emitted event "${t}" but it is neither declared in the emits option nor as an "${gt(
              be(t)
            )}" prop.`
          );
      else {
        const h = d[t];
        I(h) &&
          (h(...o) ||
            O(
              `Invalid event arguments: event validation failed for event "${t}".`
            ));
      }
  }
  let s = o;
  const i = t.startsWith("update:"),
    r = i && hc(n, t.slice(7));
  if (
    (r &&
      (r.trim && (s = o.map((d) => (q(d) ? d.trim() : d))),
      r.number && (s = o.map(Vo))),
    process.env.NODE_ENV !== "production" && _l(e, t, s),
    process.env.NODE_ENV !== "production")
  ) {
    const d = t.toLowerCase();
    d !== t &&
      n[gt(d)] &&
      O(
        `Event "${d}" is emitted in component ${qo(
          e,
          e.type
        )} but the handler is registered for "${t}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${we(
          t
        )}" instead of "${t}".`
      );
  }
  let l,
    a =
      n[(l = gt(t))] || // also try camelCase event handler (#2249)
      n[(l = gt(be(t)))];
  !a && i && (a = n[(l = gt(we(t)))]), a && Ke(a, e, 6, s);
  const p = n[l + "Once"];
  if (p) {
    if (!e.emitted) e.emitted = {};
    else if (e.emitted[l]) return;
    (e.emitted[l] = !0), Ke(p, e, 6, s);
  }
}
function Ki(e, t, o = !1) {
  const n = t.emitsCache,
    s = n.get(e);
  if (s !== void 0) return s;
  const i = e.emits;
  let r = {},
    l = !1;
  if (!I(e)) {
    const a = (p) => {
      const d = Ki(p, t, !0);
      d && ((l = !0), ee(r, d));
    };
    !o && t.mixins.length && t.mixins.forEach(a),
      e.extends && a(e.extends),
      e.mixins && e.mixins.forEach(a);
  }
  return !i && !l
    ? (G(e) && n.set(e, null), null)
    : ($(i) ? i.forEach((a) => (r[a] = null)) : ee(r, i),
      G(e) && n.set(e, r),
      r);
}
function Qo(e, t) {
  return !e || !oo(t)
    ? !1
    : ((t = t.slice(2).replace(/Once$/, "")),
      W(e, t[0].toLowerCase() + t.slice(1)) || W(e, we(t)) || W(e, t));
}
let Vn = !1;
function Mo() {
  Vn = !0;
}
function ys(e) {
  const {
      type: t,
      vnode: o,
      proxy: n,
      withProxy: s,
      propsOptions: [i],
      slots: r,
      attrs: l,
      emit: a,
      render: p,
      renderCache: d,
      props: u,
      data: h,
      setupState: m,
      ctx: N,
      inheritAttrs: C,
    } = e,
    Q = Ao(e);
  let T, L;
  process.env.NODE_ENV !== "production" && (Vn = !1);
  try {
    if (o.shapeFlag & 4) {
      const D = s || n,
        re =
          process.env.NODE_ENV !== "production" && m.__isScriptSetup
            ? new Proxy(D, {
                get(De, ce, me) {
                  return (
                    O(
                      `Property '${String(
                        ce
                      )}' was accessed via 'this'. Avoid using 'this' in templates.`
                    ),
                    Reflect.get(De, ce, me)
                  );
                },
              })
            : D;
      (T = Ce(
        p.call(
          re,
          D,
          d,
          process.env.NODE_ENV !== "production" ? Fe(u) : u,
          m,
          h,
          N
        )
      )),
        (L = l);
    } else {
      const D = t;
      process.env.NODE_ENV !== "production" && l === u && Mo(),
        (T = Ce(
          D.length > 1
            ? D(
                process.env.NODE_ENV !== "production" ? Fe(u) : u,
                process.env.NODE_ENV !== "production"
                  ? {
                      get attrs() {
                        return Mo(), Fe(l);
                      },
                      slots: r,
                      emit: a,
                    }
                  : { attrs: l, slots: r, emit: a }
              )
            : D(process.env.NODE_ENV !== "production" ? Fe(u) : u, null)
        )),
        (L = t.props ? l : mc(l));
    }
  } catch (D) {
    (Yt.length = 0), ro(D, e, 1), (T = Le(xe));
  }
  let A = T,
    te;
  if (
    (process.env.NODE_ENV !== "production" &&
      T.patchFlag > 0 &&
      T.patchFlag & 2048 &&
      ([A, te] = Wi(T)),
    L && C !== !1)
  ) {
    const D = Object.keys(L),
      { shapeFlag: re } = A;
    if (D.length) {
      if (re & 7) i && D.some(Oo) && (L = _c(L, i)), (A = dt(A, L, !1, !0));
      else if (process.env.NODE_ENV !== "production" && !Vn && A.type !== xe) {
        const De = Object.keys(l),
          ce = [],
          me = [];
        for (let We = 0, ot = De.length; We < ot; We++) {
          const Se = De[We];
          oo(Se)
            ? Oo(Se) || ce.push(Se[2].toLowerCase() + Se.slice(3))
            : me.push(Se);
        }
        me.length &&
          O(
            `Extraneous non-props attributes (${me.join(
              ", "
            )}) were passed to component but could not be automatically inherited because component renders fragment or text or teleport root nodes.`
          ),
          ce.length &&
            O(
              `Extraneous non-emits event listeners (${ce.join(
                ", "
              )}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
            );
      }
    }
  }
  return (
    o.dirs &&
      (process.env.NODE_ENV !== "production" &&
        !Es(A) &&
        O(
          "Runtime directive used on component with non-element root node. The directives will not function as intended."
        ),
      (A = dt(A, null, !1, !0)),
      (A.dirs = A.dirs ? A.dirs.concat(o.dirs) : o.dirs)),
    o.transition &&
      (process.env.NODE_ENV !== "production" &&
        !Es(A) &&
        O(
          "Component inside <Transition> renders non-element root node that cannot be animated."
        ),
      zn(A, o.transition)),
    process.env.NODE_ENV !== "production" && te ? te(A) : (T = A),
    Ao(Q),
    T
  );
}
const Wi = (e) => {
  const t = e.children,
    o = e.dynamicChildren,
    n = Qn(t, !1);
  if (n) {
    if (
      process.env.NODE_ENV !== "production" &&
      n.patchFlag > 0 &&
      n.patchFlag & 2048
    )
      return Wi(n);
  } else return [e, void 0];
  const s = t.indexOf(n),
    i = o ? o.indexOf(n) : -1,
    r = (l) => {
      (t[s] = l),
        o &&
          (i > -1
            ? (o[i] = l)
            : l.patchFlag > 0 && (e.dynamicChildren = [...o, l]));
    };
  return [Ce(n), r];
};
function Qn(e, t = !0) {
  let o;
  for (let n = 0; n < e.length; n++) {
    const s = e[n];
    if (Xo(s)) {
      if (s.type !== xe || s.children === "v-if") {
        if (o) return;
        if (
          ((o = s),
          process.env.NODE_ENV !== "production" &&
            t &&
            o.patchFlag > 0 &&
            o.patchFlag & 2048)
        )
          return Qn(o.children);
      }
    } else return;
  }
  return o;
}
const mc = (e) => {
    let t;
    for (const o in e)
      (o === "class" || o === "style" || oo(o)) && ((t || (t = {}))[o] = e[o]);
    return t;
  },
  _c = (e, t) => {
    const o = {};
    for (const n in e) (!Oo(n) || !(n.slice(9) in t)) && (o[n] = e[n]);
    return o;
  },
  Es = (e) => e.shapeFlag & 7 || e.type === xe;
function vc(e, t, o) {
  const { props: n, children: s, component: i } = e,
    { props: r, children: l, patchFlag: a } = t,
    p = i.emitsOptions;
  if (
    (process.env.NODE_ENV !== "production" && (s || l) && Ue) ||
    t.dirs ||
    t.transition
  )
    return !0;
  if (o && a >= 0) {
    if (a & 1024) return !0;
    if (a & 16) return n ? Ns(n, r, p) : !!r;
    if (a & 8) {
      const d = t.dynamicProps;
      for (let u = 0; u < d.length; u++) {
        const h = d[u];
        if (r[h] !== n[h] && !Qo(p, h)) return !0;
      }
    }
  } else
    return (s || l) && (!l || !l.$stable)
      ? !0
      : n === r
      ? !1
      : n
      ? r
        ? Ns(n, r, p)
        : !0
      : !!r;
  return !1;
}
function Ns(e, t, o) {
  const n = Object.keys(t);
  if (n.length !== Object.keys(e).length) return !0;
  for (let s = 0; s < n.length; s++) {
    const i = n[s];
    if (t[i] !== e[i] && !Qo(o, i)) return !0;
  }
  return !1;
}
function bc({ vnode: e, parent: t }, o) {
  for (; t; ) {
    const n = t.subTree;
    if ((n.suspense && n.suspense.activeBranch === e && (n.el = e.el), n === e))
      ((e = t.vnode).el = o), (t = t.parent);
    else break;
  }
}
const zi = (e) => e.__isSuspense;
function yc(e, t) {
  t && t.pendingBranch
    ? $(e)
      ? t.effects.push(...e)
      : t.effects.push(e)
    : _i(e);
}
const Z = Symbol.for("v-fgt"),
  co = Symbol.for("v-txt"),
  xe = Symbol.for("v-cmt"),
  Eo = Symbol.for("v-stc"),
  Yt = [];
let Oe = null;
function k(e = !1) {
  Yt.push((Oe = e ? null : []));
}
function Ec() {
  Yt.pop(), (Oe = Yt[Yt.length - 1] || null);
}
let qt = 1;
function ws(e, t = !1) {
  (qt += e), e < 0 && Oe && t && (Oe.hasOnce = !0);
}
function Ji(e) {
  return (
    (e.dynamicChildren = qt > 0 ? Oe || Ct : null),
    Ec(),
    qt > 0 && Oe && Oe.push(e),
    e
  );
}
function R(e, t, o, n, s, i) {
  return Ji(S(e, t, o, n, s, i, !0));
}
function Nc(e, t, o, n, s) {
  return Ji(Le(e, t, o, n, s, !0));
}
function Xo(e) {
  return e ? e.__v_isVNode === !0 : !1;
}
function Ht(e, t) {
  if (process.env.NODE_ENV !== "production" && t.shapeFlag & 6 && e.component) {
    const o = vo.get(t.type);
    if (o && o.has(e.component))
      return (e.shapeFlag &= -257), (t.shapeFlag &= -513), !1;
  }
  return e.type === t.type && e.key === t.key;
}
const wc = (...e) => Yi(...e),
  Gi = ({ key: e }) => e ?? null,
  No = ({ ref: e, ref_key: t, ref_for: o }) => (
    typeof e == "number" && (e = "" + e),
    e != null
      ? q(e) || oe(e) || I(e)
        ? { i: he, r: e, k: t, f: !!o }
        : e
      : null
  );
function S(
  e,
  t = null,
  o = null,
  n = 0,
  s = null,
  i = e === Z ? 0 : 1,
  r = !1,
  l = !1
) {
  const a = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e,
    props: t,
    key: t && Gi(t),
    ref: t && No(t),
    scopeId: wi,
    slotScopeIds: null,
    children: o,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: i,
    patchFlag: n,
    dynamicProps: s,
    dynamicChildren: null,
    appContext: null,
    ctx: he,
  };
  return (
    l
      ? (Xn(a, o), i & 128 && e.normalize(a))
      : o && (a.shapeFlag |= q(o) ? 8 : 16),
    process.env.NODE_ENV !== "production" &&
      a.key !== a.key &&
      O("VNode created with invalid key (NaN). VNode type:", a.type),
    qt > 0 && // avoid a block node from tracking itself
      !r && // has current parent block
      Oe && // presence of a patch flag indicates this node needs patching on updates.
      // component nodes also should always be patched, because even if the
      // component doesn't need to update, it needs to persist the instance on to
      // the next vnode so that it can be properly unmounted later.
      (a.patchFlag > 0 || i & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
      // vnode should not be considered dynamic due to handler caching.
      a.patchFlag !== 32 &&
      Oe.push(a),
    a
  );
}
const Le = process.env.NODE_ENV !== "production" ? wc : Yi;
function Yi(e, t = null, o = null, n = 0, s = null, i = !1) {
  if (
    ((!e || e === kl) &&
      (process.env.NODE_ENV !== "production" &&
        !e &&
        O(`Invalid vnode type when creating vnode: ${e}.`),
      (e = xe)),
    Xo(e))
  ) {
    const l = dt(
      e,
      t,
      !0
      /* mergeRef: true */
    );
    return (
      o && Xn(l, o),
      qt > 0 &&
        !i &&
        Oe &&
        (l.shapeFlag & 6 ? (Oe[Oe.indexOf(e)] = l) : Oe.push(l)),
      (l.patchFlag = -2),
      l
    );
  }
  if ((er(e) && (e = e.__vccOpts), t)) {
    t = Oc(t);
    let { class: l, style: a } = t;
    l && !q(l) && (t.class = Mn(l)),
      G(a) && (Do(a) && !$(a) && (a = ee({}, a)), (t.style = Rn(a)));
  }
  const r = q(e) ? 1 : zi(e) ? 128 : yl(e) ? 64 : G(e) ? 4 : I(e) ? 2 : 0;
  return (
    process.env.NODE_ENV !== "production" &&
      r & 4 &&
      Do(e) &&
      ((e = U(e)),
      O(
        "Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.",
        `
Component that was made reactive: `,
        e
      )),
    S(e, t, o, n, s, r, i, !0)
  );
}
function Oc(e) {
  return e ? (Do(e) || ki(e) ? ee({}, e) : e) : null;
}
function dt(e, t, o = !1, n = !1) {
  const { props: s, ref: i, patchFlag: r, children: l, transition: a } = e,
    p = t ? Vc(s || {}, t) : s,
    d = {
      __v_isVNode: !0,
      __v_skip: !0,
      type: e.type,
      props: p,
      key: p && Gi(p),
      ref:
        t && t.ref
          ? // #2078 in the case of <component :is="vnode" ref="extra"/>
            // if the vnode itself already has a ref, cloneVNode will need to merge
            // the refs so the single vnode can be set on multiple refs
            o && i
            ? $(i)
              ? i.concat(No(t))
              : [i, No(t)]
            : No(t)
          : i,
      scopeId: e.scopeId,
      slotScopeIds: e.slotScopeIds,
      children:
        process.env.NODE_ENV !== "production" && r === -1 && $(l)
          ? l.map(Qi)
          : l,
      target: e.target,
      targetStart: e.targetStart,
      targetAnchor: e.targetAnchor,
      staticCount: e.staticCount,
      shapeFlag: e.shapeFlag,
      // if the vnode is cloned with extra props, we can no longer assume its
      // existing patch flag to be reliable and need to add the FULL_PROPS flag.
      // note: preserve flag for fragments since they use the flag for children
      // fast paths only.
      patchFlag: t && e.type !== Z ? (r === -1 ? 16 : r | 16) : r,
      dynamicProps: e.dynamicProps,
      dynamicChildren: e.dynamicChildren,
      appContext: e.appContext,
      dirs: e.dirs,
      transition: a,
      // These should technically only be non-null on mounted VNodes. However,
      // they *should* be copied for kept-alive vnodes. So we just always copy
      // them since them being non-null during a mount doesn't affect the logic as
      // they will simply be overwritten.
      component: e.component,
      suspense: e.suspense,
      ssContent: e.ssContent && dt(e.ssContent),
      ssFallback: e.ssFallback && dt(e.ssFallback),
      el: e.el,
      anchor: e.anchor,
      ctx: e.ctx,
      ce: e.ce,
    };
  return a && n && zn(d, a.clone(d)), d;
}
function Qi(e) {
  const t = dt(e);
  return $(e.children) && (t.children = e.children.map(Qi)), t;
}
function xc(e = " ", t = 0) {
  return Le(co, null, e, t);
}
function ut(e = "", t = !1) {
  return t ? (k(), Nc(xe, null, e)) : Le(xe, null, e);
}
function Ce(e) {
  return e == null || typeof e == "boolean"
    ? Le(xe)
    : $(e)
    ? Le(
        Z,
        null,
        // #3666, avoid reference pollution when reusing vnode
        e.slice()
      )
    : Xo(e)
    ? lt(e)
    : Le(co, null, String(e));
}
function lt(e) {
  return (e.el === null && e.patchFlag !== -1) || e.memo ? e : dt(e);
}
function Xn(e, t) {
  let o = 0;
  const { shapeFlag: n } = e;
  if (t == null) t = null;
  else if ($(t)) o = 16;
  else if (typeof t == "object")
    if (n & 65) {
      const s = t.default;
      s && (s._c && (s._d = !1), Xn(e, s()), s._c && (s._d = !0));
      return;
    } else {
      o = 32;
      const s = t._;
      !s && !ki(t)
        ? (t._ctx = he)
        : s === 3 &&
          he &&
          (he.slots._ === 1 ? (t._ = 1) : ((t._ = 2), (e.patchFlag |= 1024)));
    }
  else
    I(t)
      ? ((t = { default: t, _ctx: he }), (o = 32))
      : ((t = String(t)), n & 64 ? ((o = 16), (t = [xc(t)])) : (o = 8));
  (e.children = t), (e.shapeFlag |= o);
}
function Vc(...e) {
  const t = {};
  for (let o = 0; o < e.length; o++) {
    const n = e[o];
    for (const s in n)
      if (s === "class")
        t.class !== n.class && (t.class = Mn([t.class, n.class]));
      else if (s === "style") t.style = Rn([t.style, n.style]);
      else if (oo(s)) {
        const i = t[s],
          r = n[s];
        r &&
          i !== r &&
          !($(i) && i.includes(r)) &&
          (t[s] = i ? [].concat(i, r) : r);
      } else s !== "" && (t[s] = n[s]);
  }
  return t;
}
function Me(e, t, o, n = null) {
  Ke(e, t, 7, [o, n]);
}
const Dc = $i();
let Sc = 0;
function Cc(e, t, o) {
  const n = e.type,
    s = (t ? t.appContext : e.appContext) || Dc,
    i = {
      uid: Sc++,
      vnode: e,
      type: n,
      parent: t,
      appContext: s,
      root: null,
      // to be immediately set
      next: null,
      subTree: null,
      // will be set synchronously right after creation
      effect: null,
      update: null,
      // will be set synchronously right after creation
      job: null,
      scope: new Or(
        !0
        /* detached */
      ),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: t ? t.provides : Object.create(s.provides),
      ids: t ? t.ids : ["", 0, 0],
      accessCache: null,
      renderCache: [],
      // local resolved assets
      components: null,
      directives: null,
      // resolved props and emits options
      propsOptions: Mi(n, s),
      emitsOptions: Ki(n, s),
      // emit
      emit: null,
      // to be set immediately
      emitted: null,
      // props default value
      propsDefaults: J,
      // inheritAttrs
      inheritAttrs: n.inheritAttrs,
      // state
      ctx: J,
      data: J,
      props: J,
      attrs: J,
      slots: J,
      refs: J,
      setupState: J,
      setupContext: null,
      // suspense related
      suspense: o,
      suspenseId: o ? o.pendingId : 0,
      asyncDep: null,
      asyncResolved: !1,
      // lifecycle hooks
      // not using enums here because it results in computed properties
      isMounted: !1,
      isUnmounted: !1,
      isDeactivated: !1,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null,
    };
  return (
    process.env.NODE_ENV !== "production"
      ? (i.ctx = Rl(i))
      : (i.ctx = { _: i }),
    (i.root = t ? t.root : i),
    (i.emit = gc.bind(null, i)),
    e.ce && e.ce(i),
    i
  );
}
let le = null;
const Tc = () => le || he;
let Io, Dn;
{
  const e = so(),
    t = (o, n) => {
      let s;
      return (
        (s = e[o]) || (s = e[o] = []),
        s.push(n),
        (i) => {
          s.length > 1 ? s.forEach((r) => r(i)) : s[0](i);
        }
      );
    };
  (Io = t("__VUE_INSTANCE_SETTERS__", (o) => (le = o))),
    (Dn = t("__VUE_SSR_SETTERS__", (o) => (eo = o)));
}
const ao = (e) => {
    const t = le;
    return (
      Io(e),
      e.scope.on(),
      () => {
        e.scope.off(), Io(t);
      }
    );
  },
  Os = () => {
    le && le.scope.off(), Io(null);
  },
  $c = /* @__PURE__ */ Ze("slot,component");
function Sn(e, { isNativeTag: t }) {
  ($c(e) || t(e)) &&
    O("Do not use built-in or reserved HTML elements as component id: " + e);
}
function Xi(e) {
  return e.vnode.shapeFlag & 4;
}
let eo = !1;
function Ac(e, t = !1, o = !1) {
  t && Dn(t);
  const { props: n, children: s } = e.vnode,
    i = Xi(e);
  Jl(e, n, i, t), sc(e, s, o);
  const r = i ? Pc(e, t) : void 0;
  return t && Dn(!1), r;
}
function Pc(e, t) {
  var o;
  const n = e.type;
  if (process.env.NODE_ENV !== "production") {
    if ((n.name && Sn(n.name, e.appContext.config), n.components)) {
      const i = Object.keys(n.components);
      for (let r = 0; r < i.length; r++) Sn(i[r], e.appContext.config);
    }
    if (n.directives) {
      const i = Object.keys(n.directives);
      for (let r = 0; r < i.length; r++) Oi(i[r]);
    }
    n.compilerOptions &&
      kc() &&
      O(
        '"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.'
      );
  }
  (e.accessCache = /* @__PURE__ */ Object.create(null)),
    (e.proxy = new Proxy(e.ctx, Si)),
    process.env.NODE_ENV !== "production" && Ml(e);
  const { setup: s } = n;
  if (s) {
    qe();
    const i = (e.setupContext = s.length > 1 ? Mc(e) : null),
      r = ao(e),
      l = Rt(s, e, 0, [
        process.env.NODE_ENV !== "production" ? Fe(e.props) : e.props,
        i,
      ]),
      a = An(l);
    if ((et(), r(), (a || e.sp) && !Gt(e) && xi(e), a)) {
      if ((l.then(Os, Os), t))
        return l
          .then((p) => {
            xs(e, p, t);
          })
          .catch((p) => {
            ro(p, e, 0);
          });
      if (
        ((e.asyncDep = l), process.env.NODE_ENV !== "production" && !e.suspense)
      ) {
        const p = (o = n.name) != null ? o : "Anonymous";
        O(
          `Component <${p}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
        );
      }
    } else xs(e, l, t);
  } else Zi(e, t);
}
function xs(e, t, o) {
  I(t)
    ? e.type.__ssrInlineRender
      ? (e.ssrRender = t)
      : (e.render = t)
    : G(t)
    ? (process.env.NODE_ENV !== "production" &&
        Xo(t) &&
        O(
          "setup() should not return VNodes directly - return a render function instead."
        ),
      process.env.NODE_ENV !== "production" && (e.devtoolsRawSetupState = t),
      (e.setupState = pi(t)),
      process.env.NODE_ENV !== "production" && Il(e))
    : process.env.NODE_ENV !== "production" &&
      t !== void 0 &&
      O(
        `setup() should return an object. Received: ${
          t === null ? "null" : typeof t
        }`
      ),
    Zi(e, o);
}
const kc = () => !0;
function Zi(e, t, o) {
  const n = e.type;
  e.render || (e.render = n.render || ie);
  {
    const s = ao(e);
    qe();
    try {
      Fl(e);
    } finally {
      et(), s();
    }
  }
  process.env.NODE_ENV !== "production" &&
    !n.render &&
    e.render === ie &&
    !t &&
    (n.template
      ? O(
          'Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".'
        )
      : O("Component is missing template or render function: ", n));
}
const Vs =
  process.env.NODE_ENV !== "production"
    ? {
        get(e, t) {
          return Mo(), se(e, "get", ""), e[t];
        },
        set() {
          return O("setupContext.attrs is readonly."), !1;
        },
        deleteProperty() {
          return O("setupContext.attrs is readonly."), !1;
        },
      }
    : {
        get(e, t) {
          return se(e, "get", ""), e[t];
        },
      };
function Rc(e) {
  return new Proxy(e.slots, {
    get(t, o) {
      return se(e, "get", "$slots"), t[o];
    },
  });
}
function Mc(e) {
  const t = (o) => {
    if (
      process.env.NODE_ENV !== "production" &&
      (e.exposed && O("expose() should be called only once per setup()."),
      o != null)
    ) {
      let n = typeof o;
      n === "object" && ($(o) ? (n = "array") : oe(o) && (n = "ref")),
        n !== "object" &&
          O(`expose() should be passed a plain object, received ${n}.`);
    }
    e.exposed = o || {};
  };
  if (process.env.NODE_ENV !== "production") {
    let o, n;
    return Object.freeze({
      get attrs() {
        return o || (o = new Proxy(e.attrs, Vs));
      },
      get slots() {
        return n || (n = Rc(e));
      },
      get emit() {
        return (s, ...i) => e.emit(s, ...i);
      },
      expose: t,
    });
  } else
    return {
      attrs: new Proxy(e.attrs, Vs),
      slots: e.slots,
      emit: e.emit,
      expose: t,
    };
}
function Zo(e) {
  return e.exposed
    ? e.exposeProxy ||
        (e.exposeProxy = new Proxy(pi(Wr(e.exposed)), {
          get(t, o) {
            if (o in t) return t[o];
            if (o in Et) return Et[o](e);
          },
          has(t, o) {
            return o in t || o in Et;
          },
        }))
    : e.proxy;
}
const Ic = /(?:^|[-_])(\w)/g,
  jc = (e) => e.replace(Ic, (t) => t.toUpperCase()).replace(/[-_]/g, "");
function qi(e, t = !0) {
  return I(e) ? e.displayName || e.name : e.name || (t && e.__name);
}
function qo(e, t, o = !1) {
  let n = qi(t);
  if (!n && t.__file) {
    const s = t.__file.match(/([^/\\]+)\.\w+$/);
    s && (n = s[1]);
  }
  if (!n && e && e.parent) {
    const s = (i) => {
      for (const r in i) if (i[r] === t) return r;
    };
    n =
      s(e.components || e.parent.type.components) || s(e.appContext.components);
  }
  return n ? jc(n) : o ? "App" : "Anonymous";
}
function er(e) {
  return I(e) && "__vccOpts" in e;
}
const jo = (e, t) => {
  const o = Qr(e, t, eo);
  if (process.env.NODE_ENV !== "production") {
    const n = Tc();
    n && n.appContext.config.warnRecursiveComputed && (o._warnRecursive = !0);
  }
  return o;
};
function Fc() {
  if (process.env.NODE_ENV === "production" || typeof window > "u") return;
  const e = { style: "color:#3ba776" },
    t = { style: "color:#1677ff" },
    o = { style: "color:#f5222d" },
    n = { style: "color:#eb2f96" },
    s = {
      __vue_custom_formatter: !0,
      header(u) {
        return G(u)
          ? u.__isVue
            ? ["div", e, "VueInstance"]
            : oe(u)
            ? [
                "div",
                {},
                ["span", e, d(u)],
                "<",
                // avoid debugger accessing value affecting behavior
                l("_value" in u ? u._value : u),
                ">",
              ]
            : bt(u)
            ? [
                "div",
                {},
                ["span", e, ge(u) ? "ShallowReactive" : "Reactive"],
                "<",
                l(u),
                `>${Xe(u) ? " (readonly)" : ""}`,
              ]
            : Xe(u)
            ? [
                "div",
                {},
                ["span", e, ge(u) ? "ShallowReadonly" : "Readonly"],
                "<",
                l(u),
                ">",
              ]
            : null
          : null;
      },
      hasBody(u) {
        return u && u.__isVue;
      },
      body(u) {
        if (u && u.__isVue) return ["div", {}, ...i(u.$)];
      },
    };
  function i(u) {
    const h = [];
    u.type.props && u.props && h.push(r("props", U(u.props))),
      u.setupState !== J && h.push(r("setup", u.setupState)),
      u.data !== J && h.push(r("data", U(u.data)));
    const m = a(u, "computed");
    m && h.push(r("computed", m));
    const N = a(u, "inject");
    return (
      N && h.push(r("injected", N)),
      h.push([
        "div",
        {},
        [
          "span",
          {
            style: n.style + ";opacity:0.66",
          },
          "$ (internal): ",
        ],
        ["object", { object: u }],
      ]),
      h
    );
  }
  function r(u, h) {
    return (
      (h = ee({}, h)),
      Object.keys(h).length
        ? [
            "div",
            { style: "line-height:1.25em;margin-bottom:0.6em" },
            [
              "div",
              {
                style: "color:#476582",
              },
              u,
            ],
            [
              "div",
              {
                style: "padding-left:1.25em",
              },
              ...Object.keys(h).map((m) => [
                "div",
                {},
                ["span", n, m + ": "],
                l(h[m], !1),
              ]),
            ],
          ]
        : ["span", {}]
    );
  }
  function l(u, h = !0) {
    return typeof u == "number"
      ? ["span", t, u]
      : typeof u == "string"
      ? ["span", o, JSON.stringify(u)]
      : typeof u == "boolean"
      ? ["span", n, u]
      : G(u)
      ? ["object", { object: h ? U(u) : u }]
      : ["span", o, String(u)];
  }
  function a(u, h) {
    const m = u.type;
    if (I(m)) return;
    const N = {};
    for (const C in u.ctx) p(m, C, h) && (N[C] = u.ctx[C]);
    return N;
  }
  function p(u, h, m) {
    const N = u[m];
    if (
      ($(N) && N.includes(h)) ||
      (G(N) && h in N) ||
      (u.extends && p(u.extends, h, m)) ||
      (u.mixins && u.mixins.some((C) => p(C, h, m)))
    )
      return !0;
  }
  function d(u) {
    return ge(u) ? "ShallowRef" : u.effect ? "ComputedRef" : "Ref";
  }
  window.devtoolsFormatters
    ? window.devtoolsFormatters.push(s)
    : (window.devtoolsFormatters = [s]);
}
const Ds = "3.5.13",
  Ve = process.env.NODE_ENV !== "production" ? O : ie;
process.env.NODE_ENV;
process.env.NODE_ENV;
/**
 * @vue/runtime-dom v3.5.13
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
let Cn;
const Ss = typeof window < "u" && window.trustedTypes;
if (Ss)
  try {
    Cn = /* @__PURE__ */ Ss.createPolicy("vue", {
      createHTML: (e) => e,
    });
  } catch (e) {
    process.env.NODE_ENV !== "production" &&
      Ve(`Error creating trusted types policy: ${e}`);
  }
const tr = Cn ? (e) => Cn.createHTML(e) : (e) => e,
  Uc = "http://www.w3.org/2000/svg",
  Lc = "http://www.w3.org/1998/Math/MathML",
  Je = typeof document < "u" ? document : null,
  Cs = Je && /* @__PURE__ */ Je.createElement("template"),
  Hc = {
    insert: (e, t, o) => {
      t.insertBefore(e, o || null);
    },
    remove: (e) => {
      const t = e.parentNode;
      t && t.removeChild(e);
    },
    createElement: (e, t, o, n) => {
      const s =
        t === "svg"
          ? Je.createElementNS(Uc, e)
          : t === "mathml"
          ? Je.createElementNS(Lc, e)
          : o
          ? Je.createElement(e, { is: o })
          : Je.createElement(e);
      return (
        e === "select" &&
          n &&
          n.multiple != null &&
          s.setAttribute("multiple", n.multiple),
        s
      );
    },
    createText: (e) => Je.createTextNode(e),
    createComment: (e) => Je.createComment(e),
    setText: (e, t) => {
      e.nodeValue = t;
    },
    setElementText: (e, t) => {
      e.textContent = t;
    },
    parentNode: (e) => e.parentNode,
    nextSibling: (e) => e.nextSibling,
    querySelector: (e) => Je.querySelector(e),
    setScopeId(e, t) {
      e.setAttribute(t, "");
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent(e, t, o, n, s, i) {
      const r = o ? o.previousSibling : t.lastChild;
      if (s && (s === i || s.nextSibling))
        for (
          ;
          t.insertBefore(s.cloneNode(!0), o),
            !(s === i || !(s = s.nextSibling));

        );
      else {
        Cs.innerHTML = tr(
          n === "svg"
            ? `<svg>${e}</svg>`
            : n === "mathml"
            ? `<math>${e}</math>`
            : e
        );
        const l = Cs.content;
        if (n === "svg" || n === "mathml") {
          const a = l.firstChild;
          for (; a.firstChild; ) l.appendChild(a.firstChild);
          l.removeChild(a);
        }
        t.insertBefore(l, o);
      }
      return [
        // first
        r ? r.nextSibling : t.firstChild,
        // last
        o ? o.previousSibling : t.lastChild,
      ];
    },
  },
  Bc = Symbol("_vtc");
function Kc(e, t, o) {
  const n = e[Bc];
  n && (t = (t ? [t, ...n] : [...n]).join(" ")),
    t == null
      ? e.removeAttribute("class")
      : o
      ? e.setAttribute("class", t)
      : (e.className = t);
}
const Ts = Symbol("_vod"),
  Wc = Symbol("_vsh");
process.env.NODE_ENV;
const zc = Symbol(process.env.NODE_ENV !== "production" ? "CSS_VAR_TEXT" : ""),
  Jc = /(^|;)\s*display\s*:/;
function Gc(e, t, o) {
  const n = e.style,
    s = q(o);
  let i = !1;
  if (o && !s) {
    if (t)
      if (q(t))
        for (const r of t.split(";")) {
          const l = r.slice(0, r.indexOf(":")).trim();
          o[l] == null && wo(n, l, "");
        }
      else for (const r in t) o[r] == null && wo(n, r, "");
    for (const r in o) r === "display" && (i = !0), wo(n, r, o[r]);
  } else if (s) {
    if (t !== o) {
      const r = n[zc];
      r && (o += ";" + r), (n.cssText = o), (i = Jc.test(o));
    }
  } else t && e.removeAttribute("style");
  Ts in e && ((e[Ts] = i ? n.display : ""), e[Wc] && (n.display = "none"));
}
const Yc = /[^\\];\s*$/,
  $s = /\s*!important$/;
function wo(e, t, o) {
  if ($(o)) o.forEach((n) => wo(e, t, n));
  else if (
    (o == null && (o = ""),
    process.env.NODE_ENV !== "production" &&
      Yc.test(o) &&
      Ve(`Unexpected semicolon at the end of '${t}' style value: '${o}'`),
    t.startsWith("--"))
  )
    e.setProperty(t, o);
  else {
    const n = Qc(e, t);
    $s.test(o)
      ? e.setProperty(we(n), o.replace($s, ""), "important")
      : (e[n] = o);
  }
}
const As = ["Webkit", "Moz", "ms"],
  pn = {};
function Qc(e, t) {
  const o = pn[t];
  if (o) return o;
  let n = be(t);
  if (n !== "filter" && n in e) return (pn[t] = n);
  n = Bo(n);
  for (let s = 0; s < As.length; s++) {
    const i = As[s] + n;
    if (i in e) return (pn[t] = i);
  }
  return t;
}
const Ps = "http://www.w3.org/1999/xlink";
function ks(e, t, o, n, s, i = Er(t)) {
  n && t.startsWith("xlink:")
    ? o == null
      ? e.removeAttributeNS(Ps, t.slice(6, t.length))
      : e.setAttributeNS(Ps, t, o)
    : o == null || (i && !Js(o))
    ? e.removeAttribute(t)
    : e.setAttribute(t, i ? "" : He(o) ? String(o) : o);
}
function Rs(e, t, o, n, s) {
  if (t === "innerHTML" || t === "textContent") {
    o != null && (e[t] = t === "innerHTML" ? tr(o) : o);
    return;
  }
  const i = e.tagName;
  if (
    t === "value" &&
    i !== "PROGRESS" && // custom elements may use _value internally
    !i.includes("-")
  ) {
    const l = i === "OPTION" ? e.getAttribute("value") || "" : e.value,
      a =
        o == null
          ? // #11647: value should be set as empty string for null and undefined,
            // but <input type="checkbox"> should be set as 'on'.
            e.type === "checkbox"
            ? "on"
            : ""
          : String(o);
    (l !== a || !("_value" in e)) && (e.value = a),
      o == null && e.removeAttribute(t),
      (e._value = o);
    return;
  }
  let r = !1;
  if (o === "" || o == null) {
    const l = typeof e[t];
    l === "boolean"
      ? (o = Js(o))
      : o == null && l === "string"
      ? ((o = ""), (r = !0))
      : l === "number" && ((o = 0), (r = !0));
  }
  try {
    e[t] = o;
  } catch (l) {
    process.env.NODE_ENV !== "production" &&
      !r &&
      Ve(
        `Failed setting prop "${t}" on <${i.toLowerCase()}>: value ${o} is invalid.`,
        l
      );
  }
  r && e.removeAttribute(s || t);
}
function at(e, t, o, n) {
  e.addEventListener(t, o, n);
}
function Xc(e, t, o, n) {
  e.removeEventListener(t, o, n);
}
const Ms = Symbol("_vei");
function Zc(e, t, o, n, s = null) {
  const i = e[Ms] || (e[Ms] = {}),
    r = i[t];
  if (n && r) r.value = process.env.NODE_ENV !== "production" ? js(n, t) : n;
  else {
    const [l, a] = qc(t);
    if (n) {
      const p = (i[t] = oa(
        process.env.NODE_ENV !== "production" ? js(n, t) : n,
        s
      ));
      at(e, l, p, a);
    } else r && (Xc(e, l, r, a), (i[t] = void 0));
  }
}
const Is = /(?:Once|Passive|Capture)$/;
function qc(e) {
  let t;
  if (Is.test(e)) {
    t = {};
    let n;
    for (; (n = e.match(Is)); )
      (e = e.slice(0, e.length - n[0].length)), (t[n[0].toLowerCase()] = !0);
  }
  return [e[2] === ":" ? e.slice(3) : we(e.slice(2)), t];
}
let hn = 0;
const ea = /* @__PURE__ */ Promise.resolve(),
  ta = () => hn || (ea.then(() => (hn = 0)), (hn = Date.now()));
function oa(e, t) {
  const o = (n) => {
    if (!n._vts) n._vts = Date.now();
    else if (n._vts <= o.attached) return;
    Ke(na(n, o.value), t, 5, [n]);
  };
  return (o.value = e), (o.attached = ta()), o;
}
function js(e, t) {
  return I(e) || $(e)
    ? e
    : (Ve(
        `Wrong type passed as event handler to ${t} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof e}.`
      ),
      ie);
}
function na(e, t) {
  if ($(t)) {
    const o = e.stopImmediatePropagation;
    return (
      (e.stopImmediatePropagation = () => {
        o.call(e), (e._stopped = !0);
      }),
      t.map((n) => (s) => !s._stopped && n && n(s))
    );
  } else return t;
}
const Fs = (e) =>
    e.charCodeAt(0) === 111 &&
    e.charCodeAt(1) === 110 && // lowercase letter
    e.charCodeAt(2) > 96 &&
    e.charCodeAt(2) < 123,
  sa = (e, t, o, n, s, i) => {
    const r = s === "svg";
    t === "class"
      ? Kc(e, n, r)
      : t === "style"
      ? Gc(e, o, n)
      : oo(t)
      ? Oo(t) || Zc(e, t, o, n, i)
      : (
          t[0] === "."
            ? ((t = t.slice(1)), !0)
            : t[0] === "^"
            ? ((t = t.slice(1)), !1)
            : ia(e, t, n, r)
        )
      ? (Rs(e, t, n),
        !e.tagName.includes("-") &&
          (t === "value" || t === "checked" || t === "selected") &&
          ks(e, t, n, r, i, t !== "value"))
      : /* #11081 force set props for possible async custom element */ e._isVueCE &&
        (/[A-Z]/.test(t) || !q(n))
      ? Rs(e, be(t), n, i, t)
      : (t === "true-value"
          ? (e._trueValue = n)
          : t === "false-value" && (e._falseValue = n),
        ks(e, t, n, r));
  };
function ia(e, t, o, n) {
  if (n)
    return !!(
      t === "innerHTML" ||
      t === "textContent" ||
      (t in e && Fs(t) && I(o))
    );
  if (
    t === "spellcheck" ||
    t === "draggable" ||
    t === "translate" ||
    t === "form" ||
    (t === "list" && e.tagName === "INPUT") ||
    (t === "type" && e.tagName === "TEXTAREA")
  )
    return !1;
  if (t === "width" || t === "height") {
    const s = e.tagName;
    if (s === "IMG" || s === "VIDEO" || s === "CANVAS" || s === "SOURCE")
      return !1;
  }
  return Fs(t) && q(o) ? !1 : t in e;
}
const Us = {};
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function Zn(e, t, o) {
  const n = /* @__PURE__ */ El(e, t);
  Lo(n) && ee(n, t);
  class s extends qn {
    constructor(r) {
      super(n, r, o);
    }
  }
  return (s.def = n), s;
}
const ra = typeof HTMLElement < "u" ? HTMLElement : class {};
class qn extends ra {
  constructor(t, o = {}, n = Ws) {
    super(),
      (this._def = t),
      (this._props = o),
      (this._createApp = n),
      (this._isVueCE = !0),
      (this._instance = null),
      (this._app = null),
      (this._nonce = this._def.nonce),
      (this._connected = !1),
      (this._resolved = !1),
      (this._numberProps = null),
      (this._styleChildren = /* @__PURE__ */ new WeakSet()),
      (this._ob = null),
      this.shadowRoot && n !== Ws
        ? (this._root = this.shadowRoot)
        : (process.env.NODE_ENV !== "production" &&
            this.shadowRoot &&
            Ve(
              "Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use `defineSSRCustomElement`."
            ),
          t.shadowRoot !== !1
            ? (this.attachShadow({ mode: "open" }),
              (this._root = this.shadowRoot))
            : (this._root = this)),
      this._def.__asyncLoader || this._resolveProps(this._def);
  }
  connectedCallback() {
    if (!this.isConnected) return;
    this.shadowRoot || this._parseSlots(), (this._connected = !0);
    let t = this;
    for (; (t = t && (t.parentNode || t.host)); )
      if (t instanceof qn) {
        this._parent = t;
        break;
      }
    this._instance ||
      (this._resolved
        ? (this._setParent(), this._update())
        : t && t._pendingResolve
        ? (this._pendingResolve = t._pendingResolve.then(() => {
            (this._pendingResolve = void 0), this._resolveDef();
          }))
        : this._resolveDef());
  }
  _setParent(t = this._parent) {
    t &&
      ((this._instance.parent = t._instance),
      (this._instance.provides = t._instance.provides));
  }
  disconnectedCallback() {
    (this._connected = !1),
      Hn(() => {
        this._connected ||
          (this._ob && (this._ob.disconnect(), (this._ob = null)),
          this._app && this._app.unmount(),
          this._instance && (this._instance.ce = void 0),
          (this._app = this._instance = null));
      });
  }
  /**
   * resolve inner component definition (handle possible async component)
   */
  _resolveDef() {
    if (this._pendingResolve) return;
    for (let n = 0; n < this.attributes.length; n++)
      this._setAttr(this.attributes[n].name);
    (this._ob = new MutationObserver((n) => {
      for (const s of n) this._setAttr(s.attributeName);
    })),
      this._ob.observe(this, { attributes: !0 });
    const t = (n, s = !1) => {
        (this._resolved = !0), (this._pendingResolve = void 0);
        const { props: i, styles: r } = n;
        let l;
        if (i && !$(i))
          for (const a in i) {
            const p = i[a];
            (p === Number || (p && p.type === Number)) &&
              (a in this._props && (this._props[a] = is(this._props[a])),
              ((l || (l = /* @__PURE__ */ Object.create(null)))[be(a)] = !0));
          }
        (this._numberProps = l),
          s && this._resolveProps(n),
          this.shadowRoot
            ? this._applyStyles(r)
            : process.env.NODE_ENV !== "production" &&
              r &&
              Ve(
                "Custom element style injection is not supported when using shadowRoot: false"
              ),
          this._mount(n);
      },
      o = this._def.__asyncLoader;
    o
      ? (this._pendingResolve = o().then((n) => t((this._def = n), !0)))
      : t(this._def);
  }
  _mount(t) {
    process.env.NODE_ENV !== "production" && !t.name && (t.name = "VueElement"),
      (this._app = this._createApp(t)),
      t.configureApp && t.configureApp(this._app),
      (this._app._ceVNode = this._createVNode()),
      this._app.mount(this._root);
    const o = this._instance && this._instance.exposed;
    if (o)
      for (const n in o)
        W(this, n)
          ? process.env.NODE_ENV !== "production" &&
            Ve(`Exposed property "${n}" already exists on custom element.`)
          : Object.defineProperty(this, n, {
              // unwrap ref to be consistent with public instance behavior
              get: () => Pt(o[n]),
            });
  }
  _resolveProps(t) {
    const { props: o } = t,
      n = $(o) ? o : Object.keys(o || {});
    for (const s of Object.keys(this))
      s[0] !== "_" && n.includes(s) && this._setProp(s, this[s]);
    for (const s of n.map(be))
      Object.defineProperty(this, s, {
        get() {
          return this._getProp(s);
        },
        set(i) {
          this._setProp(s, i, !0, !0);
        },
      });
  }
  _setAttr(t) {
    if (t.startsWith("data-v-")) return;
    const o = this.hasAttribute(t);
    let n = o ? this.getAttribute(t) : Us;
    const s = be(t);
    o && this._numberProps && this._numberProps[s] && (n = is(n)),
      this._setProp(s, n, !1, !0);
  }
  /**
   * @internal
   */
  _getProp(t) {
    return this._props[t];
  }
  /**
   * @internal
   */
  _setProp(t, o, n = !0, s = !1) {
    if (
      o !== this._props[t] &&
      (o === Us
        ? delete this._props[t]
        : ((this._props[t] = o),
          t === "key" && this._app && (this._app._ceVNode.key = o)),
      s && this._instance && this._update(),
      n)
    ) {
      const i = this._ob;
      i && i.disconnect(),
        o === !0
          ? this.setAttribute(we(t), "")
          : typeof o == "string" || typeof o == "number"
          ? this.setAttribute(we(t), o + "")
          : o || this.removeAttribute(we(t)),
        i && i.observe(this, { attributes: !0 });
    }
  }
  _update() {
    aa(this._createVNode(), this._root);
  }
  _createVNode() {
    const t = {};
    this.shadowRoot ||
      (t.onVnodeMounted = t.onVnodeUpdated = this._renderSlots.bind(this));
    const o = Le(this._def, ee(t, this._props));
    return (
      this._instance ||
        (o.ce = (n) => {
          (this._instance = n),
            (n.ce = this),
            (n.isCE = !0),
            process.env.NODE_ENV !== "production" &&
              (n.ceReload = (i) => {
                this._styles &&
                  (this._styles.forEach((r) => this._root.removeChild(r)),
                  (this._styles.length = 0)),
                  this._applyStyles(i),
                  (this._instance = null),
                  this._update();
              });
          const s = (i, r) => {
            this.dispatchEvent(
              new CustomEvent(
                i,
                Lo(r[0]) ? ee({ detail: r }, r[0]) : { detail: r }
              )
            );
          };
          (n.emit = (i, ...r) => {
            s(i, r), we(i) !== i && s(we(i), r);
          }),
            this._setParent();
        }),
      o
    );
  }
  _applyStyles(t, o) {
    if (!t) return;
    if (o) {
      if (o === this._def || this._styleChildren.has(o)) return;
      this._styleChildren.add(o);
    }
    const n = this._nonce;
    for (let s = t.length - 1; s >= 0; s--) {
      const i = document.createElement("style");
      if (
        (n && i.setAttribute("nonce", n),
        (i.textContent = t[s]),
        this.shadowRoot.prepend(i),
        process.env.NODE_ENV !== "production")
      )
        if (o) {
          if (o.__hmrId) {
            this._childStyles ||
              (this._childStyles = /* @__PURE__ */ new Map());
            let r = this._childStyles.get(o.__hmrId);
            r || this._childStyles.set(o.__hmrId, (r = [])), r.push(i);
          }
        } else (this._styles || (this._styles = [])).push(i);
    }
  }
  /**
   * Only called when shadowRoot is false
   */
  _parseSlots() {
    const t = (this._slots = {});
    let o;
    for (; (o = this.firstChild); ) {
      const n = (o.nodeType === 1 && o.getAttribute("slot")) || "default";
      (t[n] || (t[n] = [])).push(o), this.removeChild(o);
    }
  }
  /**
   * Only called when shadowRoot is false
   */
  _renderSlots() {
    const t = (this._teleportTarget || this).querySelectorAll("slot"),
      o = this._instance.type.__scopeId;
    for (let n = 0; n < t.length; n++) {
      const s = t[n],
        i = s.getAttribute("name") || "default",
        r = this._slots[i],
        l = s.parentNode;
      if (r)
        for (const a of r) {
          if (o && a.nodeType === 1) {
            const p = o + "-s",
              d = document.createTreeWalker(a, 1);
            a.setAttribute(p, "");
            let u;
            for (; (u = d.nextNode()); ) u.setAttribute(p, "");
          }
          l.insertBefore(a, s);
        }
      else for (; s.firstChild; ) l.insertBefore(s.firstChild, s);
      l.removeChild(s);
    }
  }
  /**
   * @internal
   */
  _injectChildStyle(t) {
    this._applyStyles(t.styles, t);
  }
  /**
   * @internal
   */
  _removeChildStyle(t) {
    if (
      process.env.NODE_ENV !== "production" &&
      (this._styleChildren.delete(t), this._childStyles && t.__hmrId)
    ) {
      const o = this._childStyles.get(t.__hmrId);
      o && (o.forEach((n) => this._root.removeChild(n)), (o.length = 0));
    }
  }
}
const kt = (e) => {
  const t = e.props["onUpdate:modelValue"] || !1;
  return $(t) ? (o) => Dt(t, o) : t;
};
function la(e) {
  e.target.composing = !0;
}
function Ls(e) {
  const t = e.target;
  t.composing && ((t.composing = !1), t.dispatchEvent(new Event("input")));
}
const Qe = Symbol("_assign"),
  Ge = {
    created(e, { modifiers: { lazy: t, trim: o, number: n } }, s) {
      e[Qe] = kt(s);
      const i = n || (s.props && s.props.type === "number");
      at(e, t ? "change" : "input", (r) => {
        if (r.target.composing) return;
        let l = e.value;
        o && (l = l.trim()), i && (l = Vo(l)), e[Qe](l);
      }),
        o &&
          at(e, "change", () => {
            e.value = e.value.trim();
          }),
        t ||
          (at(e, "compositionstart", la),
          at(e, "compositionend", Ls),
          at(e, "change", Ls));
    },
    // set value on mounted so it's after min/max for type="range"
    mounted(e, { value: t }) {
      e.value = t ?? "";
    },
    beforeUpdate(
      e,
      { value: t, oldValue: o, modifiers: { lazy: n, trim: s, number: i } },
      r
    ) {
      if (((e[Qe] = kt(r)), e.composing)) return;
      const l =
          (i || e.type === "number") && !/^0\d/.test(e.value)
            ? Vo(e.value)
            : e.value,
        a = t ?? "";
      l !== a &&
        ((document.activeElement === e &&
          e.type !== "range" &&
          ((n && t === o) || (s && e.value.trim() === a))) ||
          (e.value = a));
    },
  },
  Hs = {
    created(e, { value: t }, o) {
      (e.checked = At(t, o.props.value)),
        (e[Qe] = kt(o)),
        at(e, "change", () => {
          e[Qe](to(e));
        });
    },
    beforeUpdate(e, { value: t, oldValue: o }, n) {
      (e[Qe] = kt(n)), t !== o && (e.checked = At(t, n.props.value));
    },
  },
  it = {
    // <select multiple> value need to be deep traversed
    deep: !0,
    created(e, { value: t, modifiers: { number: o } }, n) {
      const s = Uo(t);
      at(e, "change", () => {
        const i = Array.prototype.filter
          .call(e.options, (r) => r.selected)
          .map((r) => (o ? Vo(to(r)) : to(r)));
        e[Qe](e.multiple ? (s ? new Set(i) : i) : i[0]),
          (e._assigning = !0),
          Hn(() => {
            e._assigning = !1;
          });
      }),
        (e[Qe] = kt(n));
    },
    // set value in mounted & updated because <select> relies on its children
    // <option>s.
    mounted(e, { value: t }) {
      Bs(e, t);
    },
    beforeUpdate(e, t, o) {
      e[Qe] = kt(o);
    },
    updated(e, { value: t }) {
      e._assigning || Bs(e, t);
    },
  };
function Bs(e, t) {
  const o = e.multiple,
    n = $(t);
  if (o && !n && !Uo(t)) {
    process.env.NODE_ENV !== "production" &&
      Ve(
        `<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString
          .call(t)
          .slice(8, -1)}.`
      );
    return;
  }
  for (let s = 0, i = e.options.length; s < i; s++) {
    const r = e.options[s],
      l = to(r);
    if (o)
      if (n) {
        const a = typeof l;
        a === "string" || a === "number"
          ? (r.selected = t.some((p) => String(p) === String(l)))
          : (r.selected = wr(t, l) > -1);
      } else r.selected = t.has(l);
    else if (At(to(r), t)) {
      e.selectedIndex !== s && (e.selectedIndex = s);
      return;
    }
  }
  !o && e.selectedIndex !== -1 && (e.selectedIndex = -1);
}
function to(e) {
  return "_value" in e ? e._value : e.value;
}
const ca = /* @__PURE__ */ ee({ patchProp: sa }, Hc);
let Ks;
function or() {
  return Ks || (Ks = lc(ca));
}
const aa = (...e) => {
    or().render(...e);
  },
  Ws = (...e) => {
    const t = or().createApp(...e);
    process.env.NODE_ENV !== "production" && (fa(t), da(t));
    const { mount: o } = t;
    return (
      (t.mount = (n) => {
        const s = pa(n);
        if (!s) return;
        const i = t._component;
        !I(i) && !i.render && !i.template && (i.template = s.innerHTML),
          s.nodeType === 1 && (s.textContent = "");
        const r = o(s, !1, ua(s));
        return (
          s instanceof Element &&
            (s.removeAttribute("v-cloak"), s.setAttribute("data-v-app", "")),
          r
        );
      }),
      t
    );
  };
function ua(e) {
  if (e instanceof SVGElement) return "svg";
  if (typeof MathMLElement == "function" && e instanceof MathMLElement)
    return "mathml";
}
function fa(e) {
  Object.defineProperty(e.config, "isNativeTag", {
    value: (t) => _r(t) || vr(t) || br(t),
    writable: !1,
  });
}
function da(e) {
  {
    const t = e.config.isCustomElement;
    Object.defineProperty(e.config, "isCustomElement", {
      get() {
        return t;
      },
      set() {
        Ve(
          "The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead."
        );
      },
    });
    const o = e.config.compilerOptions,
      n =
        'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc';
    Object.defineProperty(e.config, "compilerOptions", {
      get() {
        return Ve(n), o;
      },
      set() {
        Ve(n);
      },
    });
  }
}
function pa(e) {
  if (q(e)) {
    const t = document.querySelector(e);
    return (
      process.env.NODE_ENV !== "production" &&
        !t &&
        Ve(`Failed to mount app: mount target selector "${e}" returned null.`),
      t
    );
  }
  return (
    process.env.NODE_ENV !== "production" &&
      window.ShadowRoot &&
      e instanceof window.ShadowRoot &&
      e.mode === "closed" &&
      Ve(
        'mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'
      ),
    e
  );
}
/**
 * vue v3.5.13
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
function ha() {
  Fc();
}
process.env.NODE_ENV !== "production" && ha();
const ga = { class: "space-y-4" },
  ma = ["placeholder"],
  _a = { class: "flex justify-between items-center" },
  va = ["onUpdate:modelValue", "placeholder"],
  ba = ["onClick"],
  ya = { class: "space-y-2" },
  Ea = ["onUpdate:modelValue"],
  Na = ["value"],
  wa = ["onUpdate:modelValue"],
  Oa = ["onUpdate:modelValue", "placeholder"],
  xa = ["onUpdate:modelValue"],
  Va = { value: "show" },
  Da = { value: "hide" },
  Sa = ["onClick"],
  Ca = ["onClick"],
  Ta = ["onUpdate:modelValue", "placeholder"],
  $a = ["onUpdate:modelValue"],
  Aa = { value: "text" },
  Pa = { value: "textarea" },
  ka = { value: "radio" },
  Ra = { value: "checkbox" },
  Ma = { value: "date" },
  Ia = { value: "scoring" },
  ja = { value: "dropdown" },
  Fa = ["onUpdate:modelValue", "placeholder"],
  Ua = ["onClick"],
  La = ["onClick"],
  Ha = { class: "space-y-1" },
  Ba = ["onUpdate:modelValue"],
  Ka = ["value"],
  Wa = ["onUpdate:modelValue"],
  za = ["onUpdate:modelValue", "placeholder"],
  Ja = ["onUpdate:modelValue"],
  Ga = { value: "show" },
  Ya = { value: "hide" },
  Qa = ["onClick"],
  Xa = ["onClick"],
  Za = ["onClick"],
  qa = ["onClick"],
  eu = {
    __name: "Builder",
    props: {
      data: [Object, String],
      translations: [Object, String],
    },
    setup(e) {
      const t = e,
        o = {
          formTitlePlaceholder: "Form title",
          sectionTitlePlaceholder: (m) => `Section ${m + 1} title`,
          deleteSection: "Delete section",
          addRuleToSection: "+ Add Rule to Section",
          deleteRule: "Delete",
          valuePlaceholder: "Value",
          show: "Show",
          hide: "Hide",
          questionPlaceholder: (m) => `Question ${m + 1}`,
          shortAnswer: "Short answer",
          paragraph: "Paragraph",
          singleChoice: "Single choice",
          multipleChoice: "Multiple choice",
          date: "Date",
          scoring: "Scoring",
          dropdown: "Dropdown",
          optionPlaceholder: "Option",
          addOption: "Add option",
          addRuleToQuestion: "+ Add Rule to Question",
          deleteQuestion: "Delete question",
          addQuestion: "Add question",
          addSection: "Add section",
          downloadForm: "Download current form",
        },
        n = jo(() => {
          let m = {};
          try {
            m =
              typeof t.translations == "string"
                ? JSON.parse(t.translations)
                : t.translations;
          } catch (C) {
            console.error(
              "Invalid JSON string passed to `translations` prop",
              C
            );
          }
          const N = { ...o, ...m };
          return (
            typeof N.sectionTitlePlaceholder != "function" &&
              (N.sectionTitlePlaceholder = o.sectionTitlePlaceholder),
            typeof N.questionPlaceholder != "function" &&
              (N.questionPlaceholder = o.questionPlaceholder),
            N
          );
        }),
        s = So(""),
        i = So([]),
        r = () => crypto.randomUUID(),
        l = () => {
          i.value.push({ id: r(), title: "", questions: [], rules: [] });
        },
        a = (m) => {
          const N = i.value.find((C) => C.id === m);
          N &&
            N.questions.push({
              id: r(),
              text: "",
              type: "text",
              options: [],
              rules: [],
            });
        },
        p = (m) => {
          i.value[m].rules.push({
            if: { questionId: "", operator: "===", value: "" },
            then: { action: "show" },
          });
        },
        d = (m, N) => {
          (i.value[m].questions[N].rules = i.value[m].questions[N].rules || []),
            i.value[m].questions[N].rules.push({
              if: { questionId: "", operator: "===", value: "" },
              then: { action: "show" },
            });
        },
        u = jo(() => i.value.flatMap((m) => m.questions)),
        h = () => {
          const m = {
              title: s.value,
              sections: i.value.map((T) => ({
                id: T.id,
                title: T.title,
                rules: T.rules || [],
                questions: T.questions.map((L) => ({
                  id: L.id,
                  text: L.text,
                  type: L.type,
                  options: L.options,
                  rules: L.rules || [],
                  answer: L.answer ?? null,
                })),
              })),
            },
            N = new Blob([JSON.stringify(m, null, 2)], {
              type: "application/json",
            }),
            C = URL.createObjectURL(N),
            Q = document.createElement("a");
          (Q.href = C),
            (Q.download = "form-schema.json"),
            Q.click(),
            URL.revokeObjectURL(C);
        };
      return (
        Yo(() => {
          let m = null;
          try {
            m = typeof t.data == "string" ? JSON.parse(t.data) : t.data;
          } catch (N) {
            console.error("Invalid JSON string passed to `data` prop", N);
          }
          m &&
            ((s.value = m.title || ""),
            (i.value = (m.sections || []).map(
              (N) => (
                N.id || (N.id = r()),
                (N.questions = (N.questions || []).map(
                  (C) => (C.id || (C.id = r()), C)
                )),
                N
              )
            )));
        }),
        (m, N) => (
          k(),
          R("div", ga, [
            ne(
              S(
                "input",
                {
                  "onUpdate:modelValue": N[0] || (N[0] = (C) => (s.value = C)),
                  placeholder: n.value.formTitlePlaceholder,
                  class: "text-2xl font-semibold border rounded p-2 w-full",
                },
                null,
                8,
                ma
              ),
              [[Ge, s.value]]
            ),
            (k(!0),
            R(
              Z,
              null,
              ae(
                i.value,
                (C, Q) => (
                  k(),
                  R(
                    "div",
                    {
                      key: C.id,
                      class: "border rounded p-4 space-y-4",
                    },
                    [
                      S("div", _a, [
                        ne(
                          S(
                            "input",
                            {
                              "onUpdate:modelValue": (T) => (C.title = T),
                              placeholder: n.value.sectionTitlePlaceholder(Q),
                              class: "w-full border rounded p-2 font-semibold",
                            },
                            null,
                            8,
                            va
                          ),
                          [[Ge, C.title]]
                        ),
                        S(
                          "button",
                          {
                            onClick: () => i.value.splice(Q, 1),
                            class: "text-red-600 ml-4",
                          },
                          F(n.value.deleteSection),
                          9,
                          ba
                        ),
                      ]),
                      S("div", ya, [
                        (k(!0),
                        R(
                          Z,
                          null,
                          ae(
                            C.rules,
                            (T, L) => (
                              k(),
                              R(
                                "div",
                                {
                                  key: L,
                                  class: "flex gap-2 items-center",
                                },
                                [
                                  ne(
                                    S(
                                      "select",
                                      {
                                        "onUpdate:modelValue": (A) =>
                                          (T.if.questionId = A),
                                        class: "border rounded p-1",
                                      },
                                      [
                                        (k(!0),
                                        R(
                                          Z,
                                          null,
                                          ae(
                                            u.value,
                                            (A) => (
                                              k(),
                                              R(
                                                "option",
                                                {
                                                  value: A.id,
                                                },
                                                F(A.text),
                                                9,
                                                Na
                                              )
                                            )
                                          ),
                                          256
                                        )),
                                      ],
                                      8,
                                      Ea
                                    ),
                                    [[it, T.if.questionId]]
                                  ),
                                  ne(
                                    S(
                                      "select",
                                      {
                                        "onUpdate:modelValue": (A) =>
                                          (T.if.operator = A),
                                        class: "border rounded p-1",
                                      },
                                      N[1] ||
                                        (N[1] = [
                                          S(
                                            "option",
                                            { value: "===" },
                                            "===",
                                            -1
                                          ),
                                          S("option", { value: ">" }, ">", -1),
                                          S(
                                            "option",
                                            { value: ">=" },
                                            ">=",
                                            -1
                                          ),
                                        ]),
                                      8,
                                      wa
                                    ),
                                    [[it, T.if.operator]]
                                  ),
                                  ne(
                                    S(
                                      "input",
                                      {
                                        "onUpdate:modelValue": (A) =>
                                          (T.if.value = A),
                                        placeholder: n.value.valuePlaceholder,
                                        class: "border rounded p-1",
                                      },
                                      null,
                                      8,
                                      Oa
                                    ),
                                    [[Ge, T.if.value]]
                                  ),
                                  ne(
                                    S(
                                      "select",
                                      {
                                        "onUpdate:modelValue": (A) =>
                                          (T.then.action = A),
                                        class: "border rounded p-1",
                                      },
                                      [
                                        S("option", Va, F(n.value.show), 1),
                                        S("option", Da, F(n.value.hide), 1),
                                      ],
                                      8,
                                      xa
                                    ),
                                    [[it, T.then.action]]
                                  ),
                                  S(
                                    "button",
                                    {
                                      onClick: () =>
                                        i.value[Q].rules.splice(L, 1),
                                      class: "text-red-600",
                                    },
                                    F(n.value.deleteRule),
                                    9,
                                    Sa
                                  ),
                                ]
                              )
                            )
                          ),
                          128
                        )),
                        S(
                          "button",
                          {
                            onClick: () => p(Q),
                            class: "text-blue-600 text-sm",
                          },
                          F(n.value.addRuleToSection),
                          9,
                          Ca
                        ),
                      ]),
                      (k(!0),
                      R(
                        Z,
                        null,
                        ae(
                          C.questions,
                          (T, L) => (
                            k(),
                            R(
                              "div",
                              {
                                key: T.id,
                                class: "border rounded p-4 space-y-2",
                              },
                              [
                                ne(
                                  S(
                                    "input",
                                    {
                                      "onUpdate:modelValue": (A) =>
                                        (T.text = A),
                                      placeholder:
                                        n.value.questionPlaceholder(L),
                                      class: "w-full border rounded p-2",
                                    },
                                    null,
                                    8,
                                    Ta
                                  ),
                                  [[Ge, T.text]]
                                ),
                                ne(
                                  S(
                                    "select",
                                    {
                                      "onUpdate:modelValue": (A) =>
                                        (T.type = A),
                                      class: "w-full border rounded p-2",
                                    },
                                    [
                                      S(
                                        "option",
                                        Aa,
                                        F(n.value.shortAnswer),
                                        1
                                      ),
                                      S("option", Pa, F(n.value.paragraph), 1),
                                      S(
                                        "option",
                                        ka,
                                        F(n.value.singleChoice),
                                        1
                                      ),
                                      S(
                                        "option",
                                        Ra,
                                        F(n.value.multipleChoice),
                                        1
                                      ),
                                      S("option", Ma, F(n.value.date), 1),
                                      S("option", Ia, F(n.value.scoring), 1),
                                      S("option", ja, F(n.value.dropdown), 1),
                                    ],
                                    8,
                                    $a
                                  ),
                                  [[it, T.type]]
                                ),
                                [
                                  "radio",
                                  "checkbox",
                                  "scoring",
                                  "dropdown",
                                ].includes(T.type)
                                  ? (k(),
                                    R(
                                      Z,
                                      { key: 0 },
                                      [
                                        (k(!0),
                                        R(
                                          Z,
                                          null,
                                          ae(
                                            T.options,
                                            (A, te) => (
                                              k(),
                                              R(
                                                "div",
                                                {
                                                  key: te,
                                                  class:
                                                    "flex gap-2 items-center",
                                                },
                                                [
                                                  ne(
                                                    S(
                                                      "input",
                                                      {
                                                        "onUpdate:modelValue": (
                                                          D
                                                        ) =>
                                                          (T.options[te] = D),
                                                        class:
                                                          "flex-1 border rounded p-2 bg-gray-100",
                                                        placeholder:
                                                          n.value
                                                            .optionPlaceholder,
                                                      },
                                                      null,
                                                      8,
                                                      Fa
                                                    ),
                                                    [[Ge, T.options[te]]]
                                                  ),
                                                  S(
                                                    "button",
                                                    {
                                                      onClick: () =>
                                                        T.options.splice(te, 1),
                                                      class: "text-red-600",
                                                    },
                                                    F(n.value.deleteRule),
                                                    9,
                                                    Ua
                                                  ),
                                                ]
                                              )
                                            )
                                          ),
                                          128
                                        )),
                                        S(
                                          "button",
                                          {
                                            onClick: () => T.options.push(""),
                                            class: "text-blue-600",
                                          },
                                          F(n.value.addOption),
                                          9,
                                          La
                                        ),
                                      ],
                                      64
                                    ))
                                  : ut("", !0),
                                S("div", Ha, [
                                  (k(!0),
                                  R(
                                    Z,
                                    null,
                                    ae(
                                      T.rules,
                                      (A, te) => (
                                        k(),
                                        R(
                                          "div",
                                          {
                                            key: te,
                                            class: "flex gap-2 items-center",
                                          },
                                          [
                                            ne(
                                              S(
                                                "select",
                                                {
                                                  "onUpdate:modelValue": (D) =>
                                                    (A.if.questionId = D),
                                                  class: "border rounded p-1",
                                                },
                                                [
                                                  (k(!0),
                                                  R(
                                                    Z,
                                                    null,
                                                    ae(
                                                      u.value,
                                                      (D) => (
                                                        k(),
                                                        R(
                                                          "option",
                                                          {
                                                            value: D.id,
                                                          },
                                                          F(D.text),
                                                          9,
                                                          Ka
                                                        )
                                                      )
                                                    ),
                                                    256
                                                  )),
                                                ],
                                                8,
                                                Ba
                                              ),
                                              [[it, A.if.questionId]]
                                            ),
                                            ne(
                                              S(
                                                "select",
                                                {
                                                  "onUpdate:modelValue": (D) =>
                                                    (A.if.operator = D),
                                                  class: "border rounded p-1",
                                                },
                                                N[2] ||
                                                  (N[2] = [
                                                    S(
                                                      "option",
                                                      { value: "===" },
                                                      "===",
                                                      -1
                                                    ),
                                                    S(
                                                      "option",
                                                      { value: ">" },
                                                      ">",
                                                      -1
                                                    ),
                                                    S(
                                                      "option",
                                                      { value: ">=" },
                                                      ">=",
                                                      -1
                                                    ),
                                                  ]),
                                                8,
                                                Wa
                                              ),
                                              [[it, A.if.operator]]
                                            ),
                                            ne(
                                              S(
                                                "input",
                                                {
                                                  "onUpdate:modelValue": (D) =>
                                                    (A.if.value = D),
                                                  placeholder:
                                                    n.value.valuePlaceholder,
                                                  class: "border rounded p-1",
                                                },
                                                null,
                                                8,
                                                za
                                              ),
                                              [[Ge, A.if.value]]
                                            ),
                                            ne(
                                              S(
                                                "select",
                                                {
                                                  "onUpdate:modelValue": (D) =>
                                                    (A.then.action = D),
                                                  class: "border rounded p-1",
                                                },
                                                [
                                                  S(
                                                    "option",
                                                    Ga,
                                                    F(n.value.show),
                                                    1
                                                  ),
                                                  S(
                                                    "option",
                                                    Ya,
                                                    F(n.value.hide),
                                                    1
                                                  ),
                                                ],
                                                8,
                                                Ja
                                              ),
                                              [[it, A.then.action]]
                                            ),
                                            S(
                                              "button",
                                              {
                                                onClick: () =>
                                                  C.questions[L].rules.splice(
                                                    te,
                                                    1
                                                  ),
                                                class: "text-red-600",
                                              },
                                              F(n.value.deleteRule),
                                              9,
                                              Qa
                                            ),
                                          ]
                                        )
                                      )
                                    ),
                                    128
                                  )),
                                  S(
                                    "button",
                                    {
                                      onClick: () => d(Q, L),
                                      class: "text-blue-600 text-sm",
                                    },
                                    F(n.value.addRuleToQuestion),
                                    9,
                                    Xa
                                  ),
                                ]),
                                S(
                                  "button",
                                  {
                                    onClick: () => C.questions.splice(L, 1),
                                    class: "text-red-600 ml-2",
                                  },
                                  F(n.value.deleteQuestion),
                                  9,
                                  Za
                                ),
                              ]
                            )
                          )
                        ),
                        128
                      )),
                      S(
                        "button",
                        {
                          onClick: () => a(C.id),
                          class: "bg-blue-500 text-white px-4 py-2 rounded",
                        },
                        F(n.value.addQuestion),
                        9,
                        qa
                      ),
                    ]
                  )
                )
              ),
              128
            )),
            S(
              "button",
              {
                onClick: l,
                class: "bg-green-600 text-white px-4 py-2 rounded",
              },
              F(n.value.addSection),
              1
            ),
            S(
              "button",
              {
                onClick: h,
                class: "bg-amber-600 text-white px-4 py-2 ml-2 rounded",
              },
              F(n.value.downloadForm),
              1
            ),
          ])
        )
      );
    },
  };
function tu(e, t) {
  const o = t[e.if.questionId],
    n = e.if.value;
  switch (e.if.operator) {
    case "===":
      return o === n;
    case "!==":
      return o !== n;
    case ">":
      return o > n;
    case "<":
      return o < n;
    case ">=":
      return o >= n;
    case "<=":
      return o <= n;
    case "includes":
      return Array.isArray(o) && o.includes(n);
    default:
      return !1;
  }
}
function Fo(e = [], t) {
  if (e.length === 0) return !0;
  for (const o of e) {
    const n = tu(o, t);
    if ((o.then.action === "hide" && n) || (o.then.action === "show" && !n))
      return !1;
  }
  return !0;
}
const ou = { class: "space-y-4" },
  nu = { class: "text-xl font-bold" },
  su = { key: 0 },
  iu = { class: "text-lg font-semibold" },
  ru = { key: 0 },
  lu = { class: "font-medium mb-2" },
  cu = { key: 0 },
  au = { class: "text-gray-700 italic" },
  uu = { key: 1 },
  fu = { class: "text-gray-700 italic" },
  du = {
    key: 2,
    class: "list-disc list-inside text-gray-700",
  },
  pu = {
    key: 0,
    class: "italic text-gray-500",
  },
  hu = { key: 3 },
  gu = { class: "text-gray-700 italic" },
  mu = {
    __name: "Viewer",
    props: {
      data: {
        type: [Object, String],
        required: !0,
      },
    },
    setup(e) {
      const t = e,
        o = So({
          title: "",
          sections: [],
        }),
        n = io({});
      return (
        Yo(() => {
          let s = null;
          try {
            s = typeof t.data == "string" ? JSON.parse(t.data) : t.data;
          } catch (i) {
            console.error("Invalid JSON string passed to `data` prop:", i);
          }
          if (s) {
            o.value = s;
            for (const i of o.value.sections)
              for (const r of i.questions) n[r.id] = r.answer;
          }
        }),
        (s, i) => (
          k(),
          R("div", ou, [
            S("h2", nu, F(o.value.title), 1),
            (k(!0),
            R(
              Z,
              null,
              ae(
                o.value.sections,
                (r) => (
                  k(),
                  R(
                    "div",
                    {
                      key: r.id,
                      class: "space-y-4",
                    },
                    [
                      Pt(Fo)(r.rules, n)
                        ? (k(),
                          R("div", su, [
                            S("h3", iu, F(r.title), 1),
                            (k(!0),
                            R(
                              Z,
                              null,
                              ae(
                                r.questions,
                                (l) => (
                                  k(),
                                  R(
                                    "div",
                                    {
                                      key: l.id,
                                      class: "rounded p-4 border bg-gray-50",
                                    },
                                    [
                                      Pt(Fo)(l.rules, n)
                                        ? (k(),
                                          R("div", ru, [
                                            S("p", lu, F(l.text), 1),
                                            l.type === "text" ||
                                            l.type === "textarea" ||
                                            l.type === "date"
                                              ? (k(),
                                                R("p", cu, [
                                                  S(
                                                    "span",
                                                    au,
                                                    F(l.answer || ""),
                                                    1
                                                  ),
                                                ]))
                                              : l.type === "radio" ||
                                                l.type === "scoring"
                                              ? (k(),
                                                R("p", uu, [
                                                  S(
                                                    "span",
                                                    fu,
                                                    F(l.answer || ""),
                                                    1
                                                  ),
                                                ]))
                                              : l.type === "checkbox"
                                              ? (k(),
                                                R("ul", du, [
                                                  (k(!0),
                                                  R(
                                                    Z,
                                                    null,
                                                    ae(
                                                      l.answer,
                                                      (a, p) => (
                                                        k(),
                                                        R(
                                                          "li",
                                                          { key: p },
                                                          F(a),
                                                          1
                                                        )
                                                      )
                                                    ),
                                                    128
                                                  )),
                                                  !l.answer ||
                                                  l.answer.length === 0
                                                    ? (k(), R("li", pu, ""))
                                                    : ut("", !0),
                                                ]))
                                              : l.type === "dropdown"
                                              ? (k(),
                                                R("p", hu, [
                                                  S(
                                                    "span",
                                                    gu,
                                                    F(l.answer || ""),
                                                    1
                                                  ),
                                                ]))
                                              : ut("", !0),
                                          ]))
                                        : ut("", !0),
                                    ]
                                  )
                                )
                              ),
                              128
                            )),
                          ]))
                        : ut("", !0),
                    ]
                  )
                )
              ),
              128
            )),
          ])
        )
      );
    },
  },
  _u = { class: "space-y-4" },
  vu = { class: "text-xl font-bold" },
  bu = { key: 0 },
  yu = { class: "text-lg font-semibold" },
  Eu = { key: 0 },
  Nu = { class: "font-medium mb-2" },
  wu = ["onUpdate:modelValue", "placeholder"],
  Ou = ["onUpdate:modelValue", "placeholder"],
  xu = ["onUpdate:modelValue"],
  Vu = {
    key: 3,
    class: "space-y-1",
  },
  Du = ["name", "value", "onUpdate:modelValue"],
  Su = {
    key: 4,
    class: "space-y-1",
  },
  Cu = ["value", "checked", "onChange"],
  Tu = {
    key: 5,
    class: "space-y-1",
  },
  $u = ["value", "onUpdate:modelValue", "name"],
  Au = ["onUpdate:modelValue"],
  Pu = {
    disabled: "",
    value: "",
  },
  ku = ["value"],
  Ru = {
    __name: "Filler",
    props: {
      data: {
        type: [Object, String],
        required: !0,
      },
      translations: {
        type: [Object, String],
        default: () => ({}),
      },
    },
    setup(e) {
      const t = e,
        o = {
          yourAnswer: "Your answer",
          selectAnOption: "Select an option",
          downloadAnswers: "Download answers",
        },
        n = jo(() => {
          let a = {};
          try {
            a =
              typeof t.translations == "string"
                ? JSON.parse(t.translations)
                : t.translations;
          } catch (p) {
            console.error(
              "Invalid JSON string passed to `translations` prop:",
              p
            );
          }
          return { ...o, ...a };
        }),
        s = So({ title: "", sections: [] }),
        i = io({}),
        r = (a, p) => {
          Array.isArray(i[a]) || (i[a] = []);
          const d = i[a].indexOf(p);
          d === -1 ? i[a].push(p) : i[a].splice(d, 1);
        },
        l = () => {
          const a = JSON.parse(JSON.stringify(s.value));
          for (const h of a.sections)
            for (const m of h.questions) m.answer = i[m.id];
          const p = new Blob([JSON.stringify(a, null, 2)], {
              type: "application/json",
            }),
            d = URL.createObjectURL(p),
            u = document.createElement("a");
          (u.href = d),
            (u.download = "form-answers.json"),
            u.click(),
            URL.revokeObjectURL(d);
        };
      return (
        Yo(() => {
          let a = null;
          try {
            a = typeof t.data == "string" ? JSON.parse(t.data) : t.data;
          } catch (p) {
            console.error("Invalid JSON string passed to `data` prop:", p);
          }
          if (a) {
            s.value = a;
            for (const p of s.value.sections)
              for (const d of p.questions)
                d.id in i || (i[d.id] = d.type === "checkbox" ? [] : "");
          }
        }),
        (a, p) => (
          k(),
          R("div", _u, [
            S("h2", vu, F(s.value.title), 1),
            (k(!0),
            R(
              Z,
              null,
              ae(
                s.value.sections,
                (d) => (
                  k(),
                  R(
                    "div",
                    {
                      key: d.id,
                      class: "space-y-4",
                    },
                    [
                      Pt(Fo)(d.rules, i)
                        ? (k(),
                          R("div", bu, [
                            S("h3", yu, F(d.title), 1),
                            (k(!0),
                            R(
                              Z,
                              null,
                              ae(
                                d.questions,
                                (u) => (
                                  k(),
                                  R(
                                    "div",
                                    {
                                      key: u.id,
                                      class: "rounded p-4 border",
                                    },
                                    [
                                      Pt(Fo)(u.rules, i)
                                        ? (k(),
                                          R("div", Eu, [
                                            S("p", Nu, F(u.text), 1),
                                            u.type === "text"
                                              ? ne(
                                                  (k(),
                                                  R(
                                                    "input",
                                                    {
                                                      key: 0,
                                                      "onUpdate:modelValue": (
                                                        h
                                                      ) => (i[u.id] = h),
                                                      class:
                                                        "w-full border rounded p-2",
                                                      placeholder:
                                                        n.value.yourAnswer,
                                                    },
                                                    null,
                                                    8,
                                                    wu
                                                  )),
                                                  [[Ge, i[u.id]]]
                                                )
                                              : u.type === "textarea"
                                              ? ne(
                                                  (k(),
                                                  R(
                                                    "textarea",
                                                    {
                                                      key: 1,
                                                      "onUpdate:modelValue": (
                                                        h
                                                      ) => (i[u.id] = h),
                                                      class:
                                                        "w-full border rounded p-2",
                                                      placeholder:
                                                        n.value.yourAnswer,
                                                    },
                                                    null,
                                                    8,
                                                    Ou
                                                  )),
                                                  [[Ge, i[u.id]]]
                                                )
                                              : u.type === "date"
                                              ? ne(
                                                  (k(),
                                                  R(
                                                    "input",
                                                    {
                                                      key: 2,
                                                      type: "date",
                                                      "onUpdate:modelValue": (
                                                        h
                                                      ) => (i[u.id] = h),
                                                      class:
                                                        "w-full border rounded p-2",
                                                    },
                                                    null,
                                                    8,
                                                    xu
                                                  )),
                                                  [[Ge, i[u.id]]]
                                                )
                                              : u.type === "radio"
                                              ? (k(),
                                                R("div", Vu, [
                                                  (k(!0),
                                                  R(
                                                    Z,
                                                    null,
                                                    ae(
                                                      u.options,
                                                      (h, m) => (
                                                        k(),
                                                        R(
                                                          "div",
                                                          {
                                                            key: m,
                                                            class:
                                                              "flex items-center gap-2",
                                                          },
                                                          [
                                                            ne(
                                                              S(
                                                                "input",
                                                                {
                                                                  type: "radio",
                                                                  name: u.id,
                                                                  value: h,
                                                                  "onUpdate:modelValue":
                                                                    (N) =>
                                                                      (i[u.id] =
                                                                        N),
                                                                },
                                                                null,
                                                                8,
                                                                Du
                                                              ),
                                                              [[Hs, i[u.id]]]
                                                            ),
                                                            S(
                                                              "label",
                                                              null,
                                                              F(h),
                                                              1
                                                            ),
                                                          ]
                                                        )
                                                      )
                                                    ),
                                                    128
                                                  )),
                                                ]))
                                              : u.type === "checkbox"
                                              ? (k(),
                                                R("div", Su, [
                                                  (k(!0),
                                                  R(
                                                    Z,
                                                    null,
                                                    ae(
                                                      u.options,
                                                      (h, m) => (
                                                        k(),
                                                        R(
                                                          "div",
                                                          {
                                                            key: m,
                                                            class:
                                                              "flex items-center gap-2",
                                                          },
                                                          [
                                                            S(
                                                              "input",
                                                              {
                                                                type: "checkbox",
                                                                value: h,
                                                                checked:
                                                                  Array.isArray(
                                                                    i[u.id]
                                                                  ) &&
                                                                  i[
                                                                    u.id
                                                                  ].includes(h),
                                                                onChange: (N) =>
                                                                  r(u.id, h),
                                                              },
                                                              null,
                                                              40,
                                                              Cu
                                                            ),
                                                            S(
                                                              "label",
                                                              null,
                                                              F(h),
                                                              1
                                                            ),
                                                          ]
                                                        )
                                                      )
                                                    ),
                                                    128
                                                  )),
                                                ]))
                                              : u.type === "scoring"
                                              ? (k(),
                                                R("div", Tu, [
                                                  (k(!0),
                                                  R(
                                                    Z,
                                                    null,
                                                    ae(
                                                      u.options,
                                                      (h, m) => (
                                                        k(),
                                                        R(
                                                          "div",
                                                          {
                                                            key: m,
                                                            class:
                                                              "flex items-center gap-2",
                                                          },
                                                          [
                                                            ne(
                                                              S(
                                                                "input",
                                                                {
                                                                  type: "radio",
                                                                  value: h,
                                                                  "onUpdate:modelValue":
                                                                    (N) =>
                                                                      (i[u.id] =
                                                                        N),
                                                                  name: u.id,
                                                                },
                                                                null,
                                                                8,
                                                                $u
                                                              ),
                                                              [[Hs, i[u.id]]]
                                                            ),
                                                            S(
                                                              "label",
                                                              null,
                                                              F(h),
                                                              1
                                                            ),
                                                          ]
                                                        )
                                                      )
                                                    ),
                                                    128
                                                  )),
                                                ]))
                                              : u.type === "dropdown"
                                              ? ne(
                                                  (k(),
                                                  R(
                                                    "select",
                                                    {
                                                      key: 6,
                                                      "onUpdate:modelValue": (
                                                        h
                                                      ) => (i[u.id] = h),
                                                      class:
                                                        "w-full border rounded p-2",
                                                    },
                                                    [
                                                      S(
                                                        "option",
                                                        Pu,
                                                        F(
                                                          n.value.selectAnOption
                                                        ),
                                                        1
                                                      ),
                                                      (k(!0),
                                                      R(
                                                        Z,
                                                        null,
                                                        ae(
                                                          u.options,
                                                          (h, m) => (
                                                            k(),
                                                            R(
                                                              "option",
                                                              {
                                                                key: m,
                                                                value: h,
                                                              },
                                                              F(h),
                                                              9,
                                                              ku
                                                            )
                                                          )
                                                        ),
                                                        128
                                                      )),
                                                    ],
                                                    8,
                                                    Au
                                                  )),
                                                  [[it, i[u.id]]]
                                                )
                                              : ut("", !0),
                                          ]))
                                        : ut("", !0),
                                    ]
                                  )
                                )
                              ),
                              128
                            )),
                          ]))
                        : ut("", !0),
                    ]
                  )
                )
              ),
              128
            )),
            S(
              "button",
              {
                onClick: l,
                class: "bg-indigo-600 text-white px-4 py-2 rounded",
              },
              F(n.value.downloadAnswers),
              1
            ),
          ])
        )
      );
    },
  },
  Mu = /* @__PURE__ */ Zn(eu, { shadowRoot: !0, styles: [Tn] });
customElements.define("formify-builder", Mu);
const Iu = /* @__PURE__ */ Zn(mu, { shadowRoot: !0, styles: [Tn] });
customElements.define("formify-viewer", Iu);
const ju = /* @__PURE__ */ Zn(Ru, { shadowRoot: !0, styles: [Tn] });
customElements.define("formify-filler", ju);
